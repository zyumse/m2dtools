{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to m2dtools Documentation","text":"<p>m2dtools is a lightweight Python toolkit for molecular simulation workflows, providing utilities for structure handling, trajectory analysis, coarse-graining, and LAMMPS interfacing. It is designed to support multiscale molecular modeling with simple, modular components that can be used independently or combined into automated pipelines.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Structure and trajectory utilities   Read, write, filter, and manipulate molecular data with minimal overhead.</p> </li> <li> <p>Coarse-graining support   Tools for computing RDFs, bonded distributions, and preparing inputs for CG   force-field optimization workflows.</p> </li> <li> <p>LAMMPS helpers   Read full-style data files, extract atom and topology information, and prepare   simulation inputs.</p> </li> <li> <p>Network and graph tools   Construct connectivity networks, compute graph-based descriptors, and analyze   polymer or molecular connectivity.</p> </li> <li> <p>Modular design   Each submodule is self-contained, making it easy to integrate with existing   workflows in MD, CGMD, or ML-accelerated simulations.</p> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install m2dtools\n</code></pre> <p>Or install from source:</p> <pre><code>git clone https://github.com/zyumse/m2dtools\ncd m2dtools\npip install -e .\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Load and inspect a LAMMPS full-style data file:</p> <pre><code>from m2dtools.lmp import read_lammps_full\n\nlmp = read_lammps_full(\"system.data\")\nprint(lmp.atom_info.shape)\nprint(lmp.bonds[:10])\n</code></pre> <p>Compute an RDF from coordinates:</p> <pre><code>from m2dtools.cg import compute_rdf\nrdf, r = compute_rdf(positions, box, dr=0.01, rmax=20.0)\n</code></pre>"},{"location":"references/basic/","title":"Basic module","text":""},{"location":"references/basic/#structure","title":"Structure","text":"<p>Structural analysis helpers for molecular simulations.</p> <p>The functions in this module compute bond lengths, angles, pair distribution functions (PDF), and structure factors (SQ) for one or multiple particle species.</p>"},{"location":"references/basic/#m2dtools.basic.structure.angle_distribution","title":"<code>angle_distribution(coors, box, cutoff)</code>","text":"<p>Compute the O\u2013O\u2013O angle distribution within a cutoff.</p> <p>Parameters:</p> Name Type Description Default <code>coors</code> <code>ndarray</code> <p>Atomic coordinates with shape <code>(n_atoms, 3)</code>.</p> required <code>box</code> <code>ndarray</code> <p>Simulation cell vectors as a 3x3 matrix.</p> required <code>cutoff</code> <code>float</code> <p>Maximum O\u2013O separation to include in the triplet selection.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Angles in degrees for all qualifying triplets.</p> Source code in <code>m2dtools/basic/structure.py</code> <pre><code>def angle_distribution(coors, box, cutoff):\n    \"\"\"Compute the O\u2013O\u2013O angle distribution within a cutoff.\n\n    Parameters\n    ----------\n    coors : np.ndarray\n        Atomic coordinates with shape ``(n_atoms, 3)``.\n    box : np.ndarray\n        Simulation cell vectors as a 3x3 matrix.\n    cutoff : float\n        Maximum O\u2013O separation to include in the triplet selection.\n\n    Returns\n    -------\n    list[float]\n        Angles in degrees for all qualifying triplets.\n    \"\"\"\n    n_atom = coors.shape[0]\n    angles = []\n    rcoors = np.dot(coors, np.linalg.inv(box))\n    rdis = np.zeros([n_atom, n_atom, 3])\n    for i in range(n_atom):\n        tmp = rcoors[i]\n        rdis[i, :, :] = tmp - rcoors\n    rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5] + 1\n    rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5] - 1\n    a = np.dot(rdis[:, :, :], box)\n    dis = np.sqrt((np.square(a[:, :, 0]) + np.square(a[:, :, 1]) + np.square(a[:, :, 2])))\n\n    for i in range(n_atom):\n        for j in np.arange(i+1, n_atom):\n            for k in np.arange(j+1, n_atom):\n                if dis[i, j] &lt; cutoff and dis[i, k] &lt; cutoff and dis[j, k] &lt; cutoff:\n                    angle = calculate_angle(a[j, i, :], a[k, i, :])\n                    angles.append(angle)\n                    angle = calculate_angle(a[i, j, :], a[k, j, :])\n                    angles.append(angle)\n                    angle = calculate_angle(a[i, k, :], a[j, k, :])\n                    angles.append(angle)\n    return angles\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.structure.calculate_angle","title":"<code>calculate_angle(v1, v2)</code>","text":"<p>Calculate the angle between two vectors.</p> <p>Parameters:</p> Name Type Description Default <code>v1</code> <code>ndarray</code> <p>First vector.</p> required <code>v2</code> <code>ndarray</code> <p>Second vector.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Angle in degrees between <code>v1</code> and <code>v2</code>.</p> Source code in <code>m2dtools/basic/structure.py</code> <pre><code>def calculate_angle(v1, v2):\n    \"\"\"Calculate the angle between two vectors.\n\n    Parameters\n    ----------\n    v1 : np.ndarray\n        First vector.\n    v2 : np.ndarray\n        Second vector.\n\n    Returns\n    -------\n    float\n        Angle in degrees between ``v1`` and ``v2``.\n    \"\"\"\n    cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))\n    # convert to angle degree\n    angle = np.arccos(cos_angle)/np.pi*180\n    return angle\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.structure.pdf_sq_1type","title":"<code>pdf_sq_1type(box_size, natom, coors, r_cutoff=10, delta_r=0.01)</code>","text":"<p>Calculate PDF and SQ for a single particle type.</p> <p>Parameters:</p> Name Type Description Default <code>box_size</code> <code>float</code> <p>Length of the cubic simulation box (\u00c5).</p> required <code>natom</code> <code>int</code> <p>Number of atoms of the single particle type.</p> required <code>coors</code> <code>ndarray</code> <p>Atomic coordinates with shape <code>(n_atoms, 3)</code>.</p> required <code>r_cutoff</code> <code>float</code> <p>Maximum pair distance to consider. Default is <code>10</code>.</p> <code>10</code> <code>delta_r</code> <code>float</code> <p>Bin width for the radial histogram. Default is <code>0.01</code>.</p> <code>0.01</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple <code>(R, g1, Q, S1)</code> where <code>R</code> are radial bin centers, <code>g1</code> is the pair distribution, <code>Q</code> is the scattering vector, and <code>S1</code> is the structure factor.</p> Source code in <code>m2dtools/basic/structure.py</code> <pre><code>def pdf_sq_1type(box_size, natom, coors, r_cutoff=10, delta_r=0.01):\n    \"\"\"Calculate PDF and SQ for a single particle type.\n\n    Parameters\n    ----------\n    box_size : float\n        Length of the cubic simulation box (\u00c5).\n    natom : int\n        Number of atoms of the single particle type.\n    coors : np.ndarray\n        Atomic coordinates with shape ``(n_atoms, 3)``.\n    r_cutoff : float, optional\n        Maximum pair distance to consider. Default is ``10``.\n    delta_r : float, optional\n        Bin width for the radial histogram. Default is ``0.01``.\n\n    Returns\n    -------\n    tuple\n        Tuple ``(R, g1, Q, S1)`` where ``R`` are radial bin centers,\n        ``g1`` is the pair distribution, ``Q`` is the scattering vector,\n        and ``S1`` is the structure factor.\n    \"\"\"\n    box = np.array([[box_size, 0, 0],\n                    [0, box_size, 0],\n                    [0, 0, box_size]])\n    n1 = natom\n    rcoors = np.dot(coors, np.linalg.inv(box))\n    rdis = np.zeros([natom, natom, 3])\n    for i in range(natom):\n        tmp = rcoors[i]\n        rdis[i, :, :] = tmp - rcoors\n    rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5] + 1\n    rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5] - 1\n    a = np.dot(rdis[:, :, :], box)\n    dis = np.sqrt((np.square(a[:, :, 0]) + np.square(a[:, :, 1]) + np.square(a[:, :, 2])))\n    r_max = r_cutoff\n    r = np.linspace(delta_r, r_max, int(r_max / delta_r))\n    V = np.dot(np.cross(box[1, :], box[2, :]), box[0, :])\n    rho1 = n1 / V\n    c = np.array([rho1 * rho1]) * V\n    g1 = np.histogram(dis[:n1, :n1], bins=r)[0] / (4 * np.pi *\n                                                   (r[1:] - delta_r / 2) ** 2 * delta_r * c[0])\n    R = r[1:] - delta_r / 2\n\n    dq = 0.01\n    qrange = [np.pi / 2 / r_max, 25]\n    Q = np.arange(np.floor(qrange[0] / dq), np.floor(qrange[1] / dq), 1) * dq\n    S1 = np.zeros([len(Q)])\n    rho = natom / np.dot(np.cross(box[1, :], box[2, :]), box[0, :]) #/ 10 ** 3\n    # use a window function for fourier transform\n    for i in np.arange(len(Q)):\n        S1[i] = 1 + 4 * np.pi * rho / Q[i] * np.trapz(\n            (g1 - 1) * np.sin(Q[i] * R) * R * np.sin(np.pi * R / r_max) / (np.pi * R / r_max), R)\n\n    return R, g1, Q, S1\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.structure.pdf_sq_cross_mask","title":"<code>pdf_sq_cross_mask(box, coors1, coors2, mask_matrix, r_cutoff=10, delta_r=0.01)</code>","text":"<p>Calculate PDF and SQ between two particle sets with masking.</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>ndarray</code> <p>Simulation cell vectors as a 3x3 matrix.</p> required <code>coors1</code> <code>ndarray</code> <p>Coordinates of the first particle set with shape <code>(n1, 3)</code>.</p> required <code>coors2</code> <code>ndarray</code> <p>Coordinates of the second particle set with shape <code>(n2, 3)</code>.</p> required <code>mask_matrix</code> <code>ndarray</code> <p>Matrix masking pair contributions; masked entries are ignored.</p> required <code>r_cutoff</code> <code>float</code> <p>Maximum pair distance to consider. Default is <code>10</code>.</p> <code>10</code> <code>delta_r</code> <code>float</code> <p>Bin width for the radial histogram. Default is <code>0.01</code>.</p> <code>0.01</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple <code>(R, g1, Q, S1)</code> where <code>R</code> are radial bin centers, <code>g1</code> is the pair distribution, <code>Q</code> is the scattering vector, and <code>S1</code> is the structure factor.</p> Source code in <code>m2dtools/basic/structure.py</code> <pre><code>def pdf_sq_cross_mask(box, coors1, coors2,  mask_matrix, r_cutoff:float=10, delta_r:float=0.01):\n    \"\"\"Calculate PDF and SQ between two particle sets with masking.\n\n    Parameters\n    ----------\n    box : np.ndarray\n        Simulation cell vectors as a 3x3 matrix.\n    coors1 : np.ndarray\n        Coordinates of the first particle set with shape ``(n1, 3)``.\n    coors2 : np.ndarray\n        Coordinates of the second particle set with shape ``(n2, 3)``.\n    mask_matrix : np.ndarray\n        Matrix masking pair contributions; masked entries are ignored.\n    r_cutoff : float, optional\n        Maximum pair distance to consider. Default is ``10``.\n    delta_r : float, optional\n        Bin width for the radial histogram. Default is ``0.01``.\n\n    Returns\n    -------\n    tuple\n        Tuple ``(R, g1, Q, S1)`` where ``R`` are radial bin centers,\n        ``g1`` is the pair distribution, ``Q`` is the scattering vector,\n        and ``S1`` is the structure factor.\n    \"\"\"\n    n1 = len(coors1)\n    n2 = len(coors2)\n    natom = n1 + n2\n    rcoors1 = np.dot(coors1, np.linalg.inv(box))\n    rcoors2 = np.dot(coors2, np.linalg.inv(box))\n    rdis = np.zeros([n1, n2, 3])\n    for i in range(n1):\n        tmp = rcoors1[i]\n        rdis[i, :, :] = tmp - rcoors2\n    rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5] + 1\n    rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5] - 1\n    a = np.dot(rdis[:, :, :], box)\n    dis = np.sqrt((np.square(a[:, :, 0]) + np.square(a[:, :, 1]) + np.square(a[:, :, 2])))\n\n    dis = dis * mask_matrix\n\n    r_max = r_cutoff\n    r = np.linspace(delta_r, r_max, int(r_max / delta_r))\n    V = np.dot(np.cross(box[1, :], box[2, :]), box[0, :])\n    rho1 = n1/V\n    rho2 = n2/V\n    c = np.array([rho1 * rho2]) * V\n    g1 = np.histogram(dis, bins=r)[0] / (4 * np.pi * (r[1:] - delta_r / 2) ** 2 * delta_r * c[0])\n    R = r[1:] - delta_r / 2\n\n    dq = 0.01\n    qrange = [np.pi / 2 / r_max, 25]\n    Q = np.arange(np.floor(qrange[0] / dq), np.floor(qrange[1] / dq), 1) * dq\n    S1 = np.zeros([len(Q)])\n    rho = natom / np.dot(np.cross(box[1, :], box[2, :]), box[0, :]) #/ 10 ** 3\n    # use a window function for fourier transform\n    for i in np.arange(len(Q)):\n        S1[i] = 1 + 4 * np.pi * rho / Q[i] * np.trapz(\n            (g1 - 1) * np.sin(Q[i] * R) * R * np.sin(np.pi * R / r_max) / (np.pi * R / r_max), R)\n\n    return R, g1, Q, S1\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.structure.pdf_sq_cross_mask_large","title":"<code>pdf_sq_cross_mask_large(box, coors1, coors2, mask_matrix, r_cutoff=10.0, delta_r=0.01)</code>","text":"<p>Compute the masked cross radial distribution function (pair distribution function) g(r) between two coordinate sets using a periodic KD-tree neighbor search, optimized for large systems.</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>(array_like, shape(3, 3))</code> <p>Simulation cell vectors. Assumed orthorhombic in practice; periodic wrapping is applied using the per-axis box lengths derived from the row norms.</p> required <code>coors1</code> <code>(array_like, shape(n1, 3))</code> <p>Cartesian coordinates of species/set 1.</p> required <code>coors2</code> <code>(array_like, shape(n2, 3))</code> <p>Cartesian coordinates of species/set 2 (used to build the KD-tree).</p> required <code>mask_matrix</code> <code>(array_like, shape(n1, n2))</code> <p>Boolean (or 0/1) mask selecting which (i, j) pairs are included in the RDF. Only distances for which <code>mask_matrix[i, j]</code> is truthy contribute to the histogram.</p> required <code>r_cutoff</code> <code>float</code> <p>Cutoff radius (in the same units as coordinates) for neighbor search and RDF.</p> <code>10.0</code> <code>delta_r</code> <code>float</code> <p>Bin width for the radial histogram.</p> <code>0.01</code> <p>Returns:</p> Name Type Description <code>r_centers</code> <code>ndarray</code> <p>Radii at the centers of the histogram bins.</p> <code>g_r</code> <code>ndarray</code> <p>Estimated cross RDF g(r) for the masked pairs.</p> <code>Q</code> <code>ndarray</code> <p>Scattering vector magnitudes for the computed structure factor S(Q).</p> <code>S1</code> <code>ndarray</code> <p>Structure factor S(Q) computed from g(r).</p> Source code in <code>m2dtools/basic/structure.py</code> <pre><code>def pdf_sq_cross_mask_large(\n    box,\n    coors1,\n    coors2,\n    mask_matrix,\n    r_cutoff: float = 10.0,\n    delta_r: float = 0.01,\n):\n    \"\"\"\n    Compute the masked cross radial distribution function (pair distribution function) g(r)\n    between two coordinate sets using a periodic KD-tree neighbor search, optimized for large systems.\n\n    Parameters\n    ----------\n    box : array_like, shape (3, 3)\n        Simulation cell vectors. Assumed orthorhombic in practice; periodic wrapping is\n        applied using the per-axis box lengths derived from the row norms.\n\n    coors1 : array_like, shape (n1, 3)\n        Cartesian coordinates of species/set 1.\n\n    coors2 : array_like, shape (n2, 3)\n        Cartesian coordinates of species/set 2 (used to build the KD-tree).\n\n    mask_matrix : array_like, shape (n1, n2)\n        Boolean (or 0/1) mask selecting which (i, j) pairs are included in the RDF.\n        Only distances for which `mask_matrix[i, j]` is truthy contribute to the histogram.\n\n    r_cutoff : float, default=10.0\n        Cutoff radius (in the same units as coordinates) for neighbor search and RDF.\n\n    delta_r : float, default=0.01\n        Bin width for the radial histogram.\n\n    Returns\n    -------\n    r_centers : numpy.ndarray\n        Radii at the centers of the histogram bins.\n    g_r : numpy.ndarray\n        Estimated cross RDF g(r) for the masked pairs.\n    Q : numpy.ndarray\n        Scattering vector magnitudes for the computed structure factor S(Q).\n    S1 : numpy.ndarray\n        Structure factor S(Q) computed from g(r).\n    \"\"\"\n\n    t0 = time.time()\n    n1, n2 = len(coors1), len(coors2)\n\n    # box lengths (orthorhombic)\n    box_lengths = np.linalg.norm(box, axis=1)\n\n    # build tree\n    tree = cKDTree(\n        coors2,\n        boxsize=box_lengths \n    )\n\n    # neighbor search\n    pairs = tree.query_ball_point(coors1, r_cutoff)\n\n    # collect distances\n    distances = []\n    for i, js in enumerate(pairs):\n        if not js:\n            continue\n        for j in js:\n            if mask_matrix[i, j]:\n                d = coors1[i] - coors2[j]\n                d -= box_lengths * np.rint(d / box_lengths)\n                distances.append(np.linalg.norm(d))\n\n    distances = np.asarray(distances)\n\n    # --- PDF ---\n    r_edges = np.arange(delta_r, r_cutoff + delta_r, delta_r)\n    r_centers = 0.5 * (r_edges[1:] + r_edges[:-1])\n\n    V = np.dot(np.cross(box[1], box[2]), box[0])\n    rho1, rho2 = n1 / V, n2 / V\n    norm = rho1 * rho2 * V\n    hist, _ = np.histogram(distances, bins=r_edges)\n    g1 = hist / (4 * np.pi * r_centers**2 * delta_r * norm)\n\n    dq = 0.01\n    qrange = [np.pi / 2 / r_cutoff, 25]\n    Q = np.arange(np.floor(qrange[0] / dq), np.floor(qrange[1] / dq), 1) * dq\n    S1 = np.zeros([len(Q)])\n    natom = n1 + n2\n    rho = natom / np.dot(np.cross(box[1, :], box[2, :]), box[0, :]) #/ 10 ** 3\n    # use a window function for fourier transform\n    R = r_centers\n    r_max = r_cutoff\n    for i in np.arange(len(Q)):\n        S1[i] = 1 + 4 * np.pi * rho / Q[i] * np.trapz(\n            (g1 - 1) * np.sin(Q[i] * R) * R * np.sin(np.pi * R / r_max) / (np.pi * R / r_max), R)\n\n    print(f\"KD-tree PDF time: {time.time() - t0:.2f} s\")\n    return r_centers, g1, Q, S1\n</code></pre>"},{"location":"references/basic/#dynamics","title":"Dynamics","text":"<p>Dynamic analysis routines for trajectory data.</p>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_D","title":"<code>compute_D(time, msd, fit_from=0, dim=3)</code>","text":"<p>Compute the diffusion coefficient from an MSD curve.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>ndarray</code> <p>Time values corresponding to the MSD entries.</p> required <code>msd</code> <code>ndarray</code> <p>Mean-squared displacement values.</p> required <code>fit_from</code> <code>int</code> <p>Index at which to start the linear regression. Default is <code>0</code>.</p> <code>0</code> <code>dim</code> <code>int</code> <p>Dimensionality of the system (e.g., <code>3</code> for 3D). Default is <code>3</code>.</p> <code>3</code> <p>Returns:</p> Type Description <code>float</code> <p>Estimated diffusion coefficient in units of <code>msd/time</code>.</p> Source code in <code>m2dtools/basic/dynamics.py</code> <pre><code>def compute_D(time, msd, fit_from=0, dim=3):\n    \"\"\"Compute the diffusion coefficient from an MSD curve.\n\n    Parameters\n    ----------\n    time : np.ndarray\n        Time values corresponding to the MSD entries.\n    msd : np.ndarray\n        Mean-squared displacement values.\n    fit_from : int, optional\n        Index at which to start the linear regression. Default is ``0``.\n    dim : int, optional\n        Dimensionality of the system (e.g., ``3`` for 3D). Default is ``3``.\n\n    Returns\n    -------\n    float\n        Estimated diffusion coefficient in units of ``msd/time``.\n    \"\"\"\n    coeffs = np.polyfit(time[fit_from:], msd[fit_from:], 1)\n    D = coeffs[0] / 2 / dim # in unit of msd / time\n    return D\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_SISF","title":"<code>compute_SISF(positions, box_lengths, lag_array, k, num_vectors=100, n_repeat=100)</code>","text":"<p>Compute the self-intermediate scattering function (SISF).</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>ndarray</code> <p>Atom positions with shape <code>(n_frames, n_atoms, 3)</code>.</p> required <code>box_lengths</code> <code>ndarray or list</code> <p>Simulation box lengths per frame with shape <code>(n_frames, 3)</code>.</p> required <code>lag_array</code> <code>ndarray or list</code> <p>Lag times (in frames) at which to evaluate the SISF.</p> required <code>k</code> <code>float</code> <p>Magnitude of the wave vector <code>|k|</code>.</p> required <code>num_vectors</code> <code>int</code> <p>Number of random <code>k</code>-vectors to sample. Default is <code>100</code>.</p> <code>100</code> <code>n_repeat</code> <code>int</code> <p>Number of time origins to average over. Default is <code>100</code>.</p> <code>100</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Self-intermediate scattering values for each lag time.</p> Source code in <code>m2dtools/basic/dynamics.py</code> <pre><code>def compute_SISF(positions, box_lengths, lag_array, k, num_vectors=100, n_repeat=100):\n    \"\"\"Compute the self-intermediate scattering function (SISF).\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        Atom positions with shape ``(n_frames, n_atoms, 3)``.\n    box_lengths : np.ndarray or list\n        Simulation box lengths per frame with shape ``(n_frames, 3)``.\n    lag_array : np.ndarray or list\n        Lag times (in frames) at which to evaluate the SISF.\n    k : float\n        Magnitude of the wave vector ``|k|``.\n    num_vectors : int, optional\n        Number of random ``k``-vectors to sample. Default is ``100``.\n    n_repeat : int, optional\n        Number of time origins to average over. Default is ``100``.\n\n    Returns\n    -------\n    np.ndarray\n        Self-intermediate scattering values for each lag time.\n    \"\"\"\n    n_frames, n_atoms, _ = positions.shape\n\n    # Unwrap positions considering periodic boundary conditions\n    unwrapped_pos = np.zeros_like(positions)\n    unwrapped_pos[0] = positions[0]\n\n    for t in range(1, n_frames):\n        box_length_tmp = (box_lengths[t] + box_lengths[t - 1]) / 2\n        delta = positions[t] - unwrapped_pos[t - 1]\n        delta -= box_length_tmp * np.round(delta / box_length_tmp)\n        unwrapped_pos[t] = unwrapped_pos[t - 1] + delta\n\n    sisf = np.zeros(len(lag_array))\n    vectors=random_vectors(k, num_vectors)\n\n    for i, lag in enumerate(lag_array):\n        if len(positions)-lag &lt; n_repeat:\n            displacements = unwrapped_pos[lag:] - unwrapped_pos[:-lag]\n            #compute cos(k*r) for each random vector and average\n            cos_kr = np.cos(np.einsum('ij,tkj-&gt;tki', vectors, displacements))\n        else:\n            random_indices = np.random.choice(len(positions)-lag, n_repeat)\n            displacements = unwrapped_pos[lag + random_indices] - unwrapped_pos[random_indices]\n            cos_kr = np.cos(np.einsum('ij,tkj-&gt;tki', vectors, displacements))\n        sisf[i] = np.mean(cos_kr)\n    return sisf\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_SISF_zresolved","title":"<code>compute_SISF_zresolved(positions, box_lengths, lag_array, k, z_ranges, num_vectors=100, n_repeat=100)</code>","text":"<p>Layer-resolved SISF with z-bin assignment performed at every time origin t0.</p> <p>Parameters:</p> Name Type Description Default <code>z_ranges</code> <code>list of tuple</code> <p>List of (zmin, zmax) tuples defining the layers along z-axis.</p> required <code>Other</code> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Self-intermediate scattering values for each layer and lag time.</p> Source code in <code>m2dtools/basic/dynamics.py</code> <pre><code>def compute_SISF_zresolved(positions, box_lengths, lag_array, k,\n                            z_ranges,\n                            num_vectors=100, n_repeat=100) -&gt; np.ndarray:\n    \"\"\"\n    Layer-resolved SISF with z-bin assignment performed at every time origin t0.\n\n    Parameters\n    ----------\n    z_ranges : list of tuple\n        List of (zmin, zmax) tuples defining the layers along z-axis.\n    Other parameters are the same as in `compute_SISF`.\n\n    Returns\n    -------\n    np.ndarray\n        Self-intermediate scattering values for each layer and lag time.\n    \"\"\"\n\n    n_frames, n_atoms, _ = positions.shape\n    n_layers = len(z_ranges)\n\n    # ---- unwrap ----\n    unwrapped = np.zeros_like(positions)\n    unwrapped[0] = positions[0]\n\n    for t in range(1, n_frames):\n        box_tmp = 0.5 * (box_lengths[t] + box_lengths[t-1])\n        delta = positions[t] - unwrapped[t-1]\n        delta -= box_tmp * np.round(delta / box_tmp)\n        unwrapped[t] = unwrapped[t-1] + delta\n\n    # ---- random k vectors ----\n    vectors = random_vectors_2D(k, num_vectors)\n\n    # ---- output ----\n    sisf_layers = np.zeros((n_layers, len(lag_array)))\n\n    # ---- compute for each lag ----\n    for i, lag in enumerate(lag_array):\n\n        max_origin = n_frames - lag\n        if max_origin &lt; n_repeat:\n            origins = np.arange(max_origin)\n        else:\n            origins = np.random.choice(max_origin, n_repeat, replace=False)\n\n        # accumulator for each layer\n        accum = [ [] for _ in range(n_layers) ]\n\n        for t0 in origins:\n            z_now = unwrapped[t0, :, 2]   # z positions at time origin\n\n            # assign atoms at this time origin\n            atom_layers = []\n            for (zmin, zmax) in z_ranges:\n                atom_layers.append(np.where((z_now &gt;= zmin) &amp; (z_now &lt; zmax))[0])\n\n            # compute displacements from t0 to t0+lag\n            disp = unwrapped[t0 + lag] - unwrapped[t0]   # (N,3)\n\n            for L, atoms_L in enumerate(atom_layers):\n                if len(atoms_L) == 0:\n                    continue\n\n                d = disp[atoms_L]           # (n_atoms_L, 3)\n\n                cos_kr = np.cos(np.einsum(\"ij,nj-&gt;ni\", vectors, d))\n                accum[L].append(np.mean(cos_kr))\n\n        # average for each layer\n        for L in range(n_layers):\n            if len(accum[L]) &gt; 0:\n                sisf_layers[L, i] = np.mean(accum[L])\n\n    return sisf_layers\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_msd_pbc","title":"<code>compute_msd_pbc(positions, box_lengths, lag_array)</code>","text":"<p>Compute mean-squared displacement with periodic boundaries.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>ndarray</code> <p>Atom positions with shape <code>(n_frames, n_atoms, 3)</code>.</p> required <code>box_lengths</code> <code>ndarray or list</code> <p>Simulation box lengths per frame with shape <code>(n_frames, 3)</code>.</p> required <code>lag_array</code> <code>ndarray or list</code> <p>Lag times (in frames) at which to evaluate the MSD.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Mean-squared displacement values for each lag time.</p> Source code in <code>m2dtools/basic/dynamics.py</code> <pre><code>def compute_msd_pbc(positions, box_lengths, lag_array):\n    \"\"\"Compute mean-squared displacement with periodic boundaries.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        Atom positions with shape ``(n_frames, n_atoms, 3)``.\n    box_lengths : np.ndarray or list\n        Simulation box lengths per frame with shape ``(n_frames, 3)``.\n    lag_array : np.ndarray or list\n        Lag times (in frames) at which to evaluate the MSD.\n\n    Returns\n    -------\n    np.ndarray\n        Mean-squared displacement values for each lag time.\n    \"\"\"\n    n_frames, n_atoms, _ = positions.shape\n\n    # Unwrap positions considering periodic boundary conditions\n    unwrapped_pos = np.zeros_like(positions)\n    unwrapped_pos[0] = positions[0]\n\n    for t in range(1, n_frames):\n        box_length_tmp = (box_lengths[t] + box_lengths[t - 1]) / 2\n        delta = positions[t] - unwrapped_pos[t - 1]\n        delta -= box_length_tmp * np.round(delta / box_length_tmp)\n        unwrapped_pos[t] = unwrapped_pos[t - 1] + delta\n\n    msd = np.zeros(len(lag_array))\n\n    for i, lag in enumerate(lag_array):\n        displacements = unwrapped_pos[lag:] - unwrapped_pos[:-lag]\n        squared_displacements = np.sum(displacements**2, axis=2)\n        msd[i] = np.mean(squared_displacements)\n\n    return msd\n</code></pre>"},{"location":"references/basic/#basic","title":"Basic","text":"<p>Basic analysis utilities for molecular dynamics trajectories.</p> <p>This module gathers small helper routines for coordination numbers, angle distributions, compressibility, and force autocorrelations.</p>"},{"location":"references/basic/#m2dtools.basic.basic.CN","title":"<code>CN(box, coors, cutoff)</code>","text":"<p>Compute coordination numbers within a cutoff.</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>ndarray</code> <p>Simulation cell vectors as a 3x3 matrix.</p> required <code>coors</code> <code>ndarray</code> <p>Atomic coordinates with shape <code>(n_atoms, 3)</code>.</p> required <code>cutoff</code> <code>float</code> <p>Distance cutoff for neighbor identification.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple <code>(CN, CN_idx, CN_dist, diff)</code> containing coordination counts, neighbor indices, neighbor distances, and displacement vectors under periodic boundary conditions.</p> Source code in <code>m2dtools/basic/basic.py</code> <pre><code>def CN(box, coors, cutoff):\n    \"\"\"Compute coordination numbers within a cutoff.\n\n    Parameters\n    ----------\n    box : np.ndarray\n        Simulation cell vectors as a 3x3 matrix.\n    coors : np.ndarray\n        Atomic coordinates with shape ``(n_atoms, 3)``.\n    cutoff : float\n        Distance cutoff for neighbor identification.\n\n    Returns\n    -------\n    tuple\n        A tuple ``(CN, CN_idx, CN_dist, diff)`` containing coordination\n        counts, neighbor indices, neighbor distances, and displacement\n        vectors under periodic boundary conditions.\n    \"\"\"\n\n    rcoors = np.dot(coors, np.linalg.inv(box))\n\n    r1 = rcoors[:, np.newaxis, :]\n    r2 = rcoors[np.newaxis, :, :]\n\n    rdis = r1-r2\n\n    while np.sum((rdis &lt; -0.5) | (rdis &gt; 0.5)) &gt; 0:\n        rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5]+1\n        rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5]-1\n\n    diff = np.dot(rdis, box)\n\n    dis = np.sqrt(np.sum(np.square(diff), axis=2))\n\n    CN_idx = []\n    CN_dist = []\n    CN = np.zeros(coors.shape[0])\n    for i in range(coors.shape[0]):\n        tmp = np.argwhere((dis[i, :] &lt; cutoff) &amp; (dis[i, :] &gt; 0))\n        CN[i] = tmp.shape[0]\n        CN_idx.append(tmp)\n        CN_dist.append(dis[i, (dis[i, :] &lt; cutoff) &amp; (dis[i, :] &gt; 0)])\n    return CN, CN_idx, CN_dist, diff\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.basic.CN_kdtree","title":"<code>CN_kdtree(box, coors, cutoff)</code>","text":"<p>Coordination number using KD-tree with orthorhombic PBC.</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>(3,3) ndarray</code> <p>Orthorhombic simulation cell (diagonal matrix).</p> required <code>coors</code> <code>(N,3) ndarray</code> <p>Atomic coordinates.</p> required <code>cutoff</code> <code>float</code> <p>Distance cutoff.</p> required <p>Returns:</p> Name Type Description <code>CN</code> <code>(N,) ndarray</code> <p>Coordination number (excluding self).</p> <code>CN_idx</code> <code>list of ndarray</code> <p>Neighbor indices for each atom.</p> <code>CN_dist</code> <code>list of ndarray</code> <p>Neighbor distances for each atom.</p> Source code in <code>m2dtools/basic/basic.py</code> <pre><code>def CN_kdtree(box, coors, cutoff):\n    \"\"\"\n    Coordination number using KD-tree with orthorhombic PBC.\n\n    Parameters\n    ----------\n    box : (3,3) ndarray\n        Orthorhombic simulation cell (diagonal matrix).\n    coors : (N,3) ndarray\n        Atomic coordinates.\n    cutoff : float\n        Distance cutoff.\n\n    Returns\n    -------\n    CN : (N,) ndarray\n        Coordination number (excluding self).\n    CN_idx : list of ndarray\n        Neighbor indices for each atom.\n    CN_dist : list of ndarray\n        Neighbor distances for each atom.\n    \"\"\"\n\n    box = np.asarray(box, dtype=float)\n    coors = np.asarray(coors, dtype=float)\n\n    # --- orthorhombic check ---\n    if not np.allclose(box, np.diag(np.diag(box))):\n        raise ValueError(\"CN_kdtree_ortho requires an orthorhombic box\")\n\n    box_lengths = np.diag(box)\n    N = coors.shape[0]\n\n    # --- KD-tree with periodicity ---\n    tree = cKDTree(coors, boxsize=box_lengths)\n\n    CN = np.zeros(N, dtype=int)\n    CN_idx = []\n    CN_dist = []\n\n    # --- neighbor search ---\n    for i in range(N):\n        js = tree.query_ball_point(coors[i], cutoff)\n\n        idx_i = []\n        dist_i = []\n\n        for j in js:\n            if j == i:\n                continue\n\n            # minimum-image displacement (orthorhombic)\n            d = coors[j] - coors[i]\n            d -= box_lengths * np.rint(d / box_lengths)\n\n            r = np.sqrt(d[0]**2 + d[1]**2 + d[2]**2)\n            if r &lt; cutoff:\n                idx_i.append(j)\n                dist_i.append(r)\n\n        CN[i] = len(idx_i)\n        CN_idx.append(np.asarray(idx_i, dtype=int))\n        CN_dist.append(np.asarray(dist_i, dtype=float))\n\n    return CN, CN_idx, CN_dist\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.basic.CN_large","title":"<code>CN_large(box, coors, cutoff)</code>","text":"<p>Compute coordination numbers for large systems.</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>ndarray</code> <p>Simulation cell vectors as a 3x3 matrix.</p> required <code>coors</code> <code>ndarray</code> <p>Atomic coordinates with shape <code>(n_atoms, 3)</code>.</p> required <code>cutoff</code> <code>float</code> <p>Distance cutoff for neighbor identification.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple <code>(CN, CN_idx, CN_dist)</code> with coordination counts, neighbor indices, and neighbor distances for each atom. Note that CN does include the atom itself.</p> Source code in <code>m2dtools/basic/basic.py</code> <pre><code>def CN_large(box, coors, cutoff):\n    \"\"\"Compute coordination numbers for large systems.\n\n    Parameters\n    ----------\n    box : np.ndarray\n        Simulation cell vectors as a 3x3 matrix.\n    coors : np.ndarray\n        Atomic coordinates with shape ``(n_atoms, 3)``.\n    cutoff : float\n        Distance cutoff for neighbor identification.\n\n    Returns\n    -------\n    tuple\n        A tuple ``(CN, CN_idx, CN_dist)`` with coordination counts,\n        neighbor indices, and neighbor distances for each atom.\n        Note that CN does include the atom itself.\n    \"\"\"\n    CN = []\n    CN_idx = []\n    CN_dist = []\n    for i in range(coors.shape[0]):\n        # find atom in the cubic at the center of coord[1], within the cutoff\n        coord0 = coors[i]\n        diff_coord = coors - coord0\n        # periodic boundary condition\n        diff_coord = diff_coord - np.round(diff_coord @ np.linalg.inv(box) ) @ box\n        idx_interest = np.argwhere((diff_coord[:, 0] &gt;= -cutoff)*(diff_coord[:, 0] &lt;= cutoff)*(diff_coord[:, 1] &gt;= -cutoff)*(diff_coord[:, 1] &lt;= cutoff)*(diff_coord[:, 2] &gt;= -cutoff)*(diff_coord[:, 2] &lt;= cutoff)).flatten()\n        dist_tmp = np.linalg.norm(diff_coord[idx_interest,:], axis=1)\n        idx_CN_tmp = np.argwhere(dist_tmp&lt;=cutoff).flatten()\n        CN.append(idx_CN_tmp.shape[0])\n        CN_idx.append(idx_interest[idx_CN_tmp])\n        CN_dist.append(dist_tmp[idx_CN_tmp])\n    return CN, CN_idx, CN_dist\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.basic.calc_compressibility","title":"<code>calc_compressibility(V, T=300)</code>","text":"<p>Calculate the isothermal compressibility from volume fluctuations.</p> <p>Parameters:</p> Name Type Description Default <code>V</code> <code>ndarray</code> <p>Array of volume samples in nm^3.</p> required <code>T</code> <code>float</code> <p>Temperature in Kelvin. Default is 300 K.</p> <code>300</code> <p>Returns:</p> Type Description <code>float</code> <p>Isothermal compressibility in <code>1/Pa</code>.</p> Source code in <code>m2dtools/basic/basic.py</code> <pre><code>def calc_compressibility(V, T=300):\n    \"\"\"Calculate the isothermal compressibility from volume fluctuations.\n\n    Parameters\n    ----------\n    V : np.ndarray\n        Array of volume samples in nm^3.\n    T : float, optional\n        Temperature in Kelvin. Default is 300 K.\n\n    Returns\n    -------\n    float\n        Isothermal compressibility in ``1/Pa``.\n    \"\"\"\n    kB = 1.380649e-23  # J/K\n    V = V * 1e-27  # Convert from nm^3 to m^3\n    kappa_T = np.var(V) / (V.mean() * kB * T)\n    return kappa_T * 1e9 # to 1/GPa\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.basic.compute_autocorrelation","title":"<code>compute_autocorrelation(forces, max_lag)</code>","text":"<p>Compute the force autocorrelation function (FAF).</p> <p>Parameters:</p> Name Type Description Default <code>forces</code> <code>ndarray</code> <p>Array of shape <code>(n_frames, n_atoms, 3)</code> containing forces per atom.</p> required <code>max_lag</code> <code>int</code> <p>Maximum lag time (in frames) for computing the autocorrelation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Force autocorrelation values with length <code>max_lag</code>.</p> Source code in <code>m2dtools/basic/basic.py</code> <pre><code>def compute_autocorrelation(forces, max_lag):\n    \"\"\"Compute the force autocorrelation function (FAF).\n\n    Parameters\n    ----------\n    forces : np.ndarray\n        Array of shape ``(n_frames, n_atoms, 3)`` containing forces per\n        atom.\n    max_lag : int\n        Maximum lag time (in frames) for computing the autocorrelation.\n\n    Returns\n    -------\n    np.ndarray\n        Force autocorrelation values with length ``max_lag``.\n    \"\"\"\n    n_frames, n_atoms, _ = forces.shape\n\n    # Initialize autocorrelation array\n    faf = np.zeros(max_lag)\n\n    # Loop over lag times\n    for lag in range(max_lag):\n        # Compute dot product of forces separated by lag\n        dot_products = np.sum(forces[:n_frames - lag] * forces[lag:], axis=(1, 2))\n        faf[lag] = np.mean(dot_products)\n\n    # Normalize by the zero-lag correlation\n    faf /= faf[0]\n\n    return faf\n</code></pre>"},{"location":"references/lmp/","title":"Lammps","text":"<p>Tools for reading and writing LAMMPS data files and dumps.</p>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.average_log","title":"<code>average_log(log_files, freq=1)</code>","text":"<p>Average the log data from multiple files.</p> <p>Parameters:</p> Name Type Description Default <code>log_files</code> <code>list[str]</code> <p>List of log file names.</p> required <code>freq</code> <code>int</code> <p>Frequency of the data to be read.</p> <code>1</code> <p>Returns:</p> Type Description <code>tuple[DataFrame, DataFrame]</code> <p>Data frames containing mean and standard deviation values.</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def average_log(log_files, freq=1):\n    \"\"\"Average the log data from multiple files.\n\n    Parameters\n    ----------\n    log_files : list[str]\n        List of log file names.\n    freq : int, default 1\n        Frequency of the data to be read.\n\n    Returns\n    -------\n    tuple[pandas.DataFrame, pandas.DataFrame]\n        Data frames containing mean and standard deviation values.\n    \"\"\"\n    dfs = []\n    for i, log_file in enumerate(log_files):\n        log = read_log_lammps(log_file, freq=freq)[-1]\n        dfs.append(log)\n\n    # Stack into a 3D array (frames \u00d7 rows \u00d7 columns)\n    stacked = pd.concat(dfs, keys=range(len(dfs)))  # adds outer index (frame index)\n\n    # Compute mean and std over the first level (i.e., over frames)\n    df_mean = stacked.groupby(level=1).mean()\n    df_std = stacked.groupby(level=1).std()\n    return df_mean, df_std\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.convert_lmp","title":"<code>convert_lmp(file_lmp, file_key, mapping_dict)</code>","text":"<p>Convert LAMMPS data file using the provided mapping dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>file_lmp</code> <code>str</code> <p>Path to the original LAMMPS data file.</p> required <code>file_key</code> <code>str</code> <p>Path to the key file for atom types.</p> required <code>mapping_dict</code> <code>dict</code> <p>Dictionary containing mapping information for bonds, angles, dihedrals, and masses.</p> required <p>Returns:</p> Name Type Description <code>lmp</code> <code>object</code> <p>Converted LAMMPS object.</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def convert_lmp(file_lmp, file_key, mapping_dict):\n    \"\"\"\n    Convert LAMMPS data file using the provided mapping dictionary.\n\n    Parameters\n    ----------\n    file_lmp : str\n        Path to the original LAMMPS data file.\n    file_key : str\n        Path to the key file for atom types.\n    mapping_dict : dict\n        Dictionary containing mapping information for bonds, angles, dihedrals, and masses.\n\n    Returns\n    -------\n    lmp: object\n        Converted LAMMPS object.\n    \"\"\"\n\n    lmp_react1 = read_lammps_full(file_lmp)\n    tmp = pd.read_table(file_key,\n                        header=None, sep='\\s+', skiprows=31, nrows=lmp_react1.natoms)\n\n    mapping = np.zeros([lmp_react1.natoms, 2])\n    mapping[:, 0] = np.arange(lmp_react1.natoms)+1\n    # modify the types given by Ligpargen\n\n    for i, type in enumerate(mapping_dict['unique_type']):\n        mapping[tmp.iloc[:, 3] == type, 1] = i+1\n\n    # natom_types_new = len(mapping_dict['mass_new'])\n    atom_info_new = lmp_react1.atom_info.copy()\n    atom_info_new[:, 2] = mapping[:, 1]\n\n    ### bonds ####\n    bond_info_new = lmp_react1.bond_info.copy()\n    for i in range(lmp_react1.natoms):\n        bond_info_new[lmp_react1.bond_info[:, 2] == i+1, 2] = mapping[i, 1]\n        bond_info_new[lmp_react1.bond_info[:, 3] == i+1, 3] = mapping[i, 1]\n\n    for i in range(len(bond_info_new)):\n        if bond_info_new[i, 2] &gt; bond_info_new[i, 3]:\n            tmp = bond_info_new[i, 3]\n            bond_info_new[i, 3] = bond_info_new[i, 2]\n            bond_info_new[i, 2] = tmp\n\n    for i in range(len(bond_info_new)):\n        bond_info_new[i, 1] = 0\n        for j in range(len(mapping_dict['mapping_bonds'])):\n            if ((bond_info_new[i, 2] == mapping_dict['mapping_bonds'][j, 0]) and (bond_info_new[i, 3] == mapping_dict['mapping_bonds'][j, 1])):\n                bond_info_new[i, 2] = lmp_react1.bond_info[i, 2]\n                bond_info_new[i, 3] = lmp_react1.bond_info[i, 3]\n                bond_info_new[i, 1] = j+1\n    print(np.sum(bond_info_new[:, 1] == 0))\n\n    # nangle_types_new = len(mapping_dict['angle_coeff_new'])\n    ### angles ####\n    angle_info_new = lmp_react1.angle_info.copy()\n    for i in range(lmp_react1.natoms):\n        angle_info_new[lmp_react1.angle_info[:, 2] == i+1, 2] = mapping[i, 1]\n        angle_info_new[lmp_react1.angle_info[:, 3] == i+1, 3] = mapping[i, 1]\n        angle_info_new[lmp_react1.angle_info[:, 4] == i+1, 4] = mapping[i, 1]\n\n    for i in range(len(angle_info_new)):\n        if angle_info_new[i, 2] &gt; angle_info_new[i, 4]:\n            tmp = angle_info_new[i, 4]\n            angle_info_new[i, 4] = angle_info_new[i, 2]\n            angle_info_new[i, 2] = tmp\n\n    for i in range(len(angle_info_new)):\n        angle_info_new[i, 1] = 0\n        match = 0\n        for j in range(len(mapping_dict['mapping_angles'])):\n            if (angle_info_new[i, 3] == mapping_dict['mapping_angles'][j, 1]) and ((angle_info_new[i, 2] == mapping_dict['mapping_angles'][j, 0]) and (angle_info_new[i, 4] == mapping_dict['mapping_angles'][j, 2])):\n                angle_info_new[i, 2] = lmp_react1.angle_info[i, 2]\n                angle_info_new[i, 3] = lmp_react1.angle_info[i, 3]\n                angle_info_new[i, 4] = lmp_react1.angle_info[i, 4]\n                angle_info_new[i, 1] = j+1\n                match += 1\n        if match == 0:\n            print(angle_info_new[i])\n    print(np.sum(angle_info_new[:, 1] == 0))\n    ### dihedrals ####\n    dihedral_info_new = lmp_react1.dihedral_info.copy()\n    for i in range(lmp_react1.natoms):\n        dihedral_info_new[lmp_react1.dihedral_info[:, 2] == i+1, 2] = mapping[i, 1]\n        dihedral_info_new[lmp_react1.dihedral_info[:, 3] == i+1, 3] = mapping[i, 1]\n        dihedral_info_new[lmp_react1.dihedral_info[:, 4] == i+1, 4] = mapping[i, 1]\n        dihedral_info_new[lmp_react1.dihedral_info[:, 5] == i+1, 5] = mapping[i, 1]\n\n    for i in range(len(dihedral_info_new)):\n        dihedral_info_new[i, 1] = 0\n        match = 0\n        for j in range(len(mapping_dict['mapping_dihedrals'])):\n            if ((dihedral_info_new[i, 2] == mapping_dict['mapping_dihedrals'][j, 0]) and (dihedral_info_new[i, 3] == mapping_dict['mapping_dihedrals'][j, 1]) and (dihedral_info_new[i, 4] == mapping_dict['mapping_dihedrals'][j, 2]) and (dihedral_info_new[i, 5] == mapping_dict['mapping_dihedrals'][j, 3])) or ((dihedral_info_new[i, 2] == mapping_dict['mapping_dihedrals'][j, 3]) and (dihedral_info_new[i, 3] == mapping_dict['mapping_dihedrals'][j, 2]) and (dihedral_info_new[i, 4] == mapping_dict['mapping_dihedrals'][j, 1]) and (dihedral_info_new[i, 5] == mapping_dict['mapping_dihedrals'][j, 0])):\n                dihedral_info_new[i, 2] = lmp_react1.dihedral_info[i, 2]\n                dihedral_info_new[i, 3] = lmp_react1.dihedral_info[i, 3]\n                dihedral_info_new[i, 4] = lmp_react1.dihedral_info[i, 4]\n                dihedral_info_new[i, 5] = lmp_react1.dihedral_info[i, 5]\n                dihedral_info_new[i, 1] = j+1\n                match += 1\n        if match == 0:\n            dihedral_info_new[i, 2] = lmp_react1.dihedral_info[i, 2]\n            dihedral_info_new[i, 3] = lmp_react1.dihedral_info[i, 3]\n            dihedral_info_new[i, 4] = lmp_react1.dihedral_info[i, 4]\n            dihedral_info_new[i, 5] = lmp_react1.dihedral_info[i, 5]\n            dihedral_info_new[i, 1] = mapping_dict['dihedral_coeff_new'][np.sum(\n                mapping_dict['dihedral_coeff_new'][:, 1:], axis=1) == 0, 0][0]\n            print(dihedral_info_new[i])\n\n    dihedral_info_new = np.delete(dihedral_info_new, np.squeeze(\n        np.argwhere(dihedral_info_new[:, 1] == 0)), 0)\n    ndihedrals = len(dihedral_info_new)\n    dihedral_info_new[:, 0] = np.arange(1, ndihedrals+1)\n\n    print(np.sum(dihedral_info_new[:, 1] == 0))\n\n    nimproper_types_new = len(mapping_dict['improper_coeff_new'])\n    ### impropers ####\n    impropers_info_new = lmp_react1.improper_info.copy()\n    for i in range(lmp_react1.natoms):\n        impropers_info_new[lmp_react1.improper_info[:, 2] == i+1, 2] = mapping[i, 1]\n        impropers_info_new[lmp_react1.improper_info[:, 3] == i+1, 3] = mapping[i, 1]\n        impropers_info_new[lmp_react1.improper_info[:, 4] == i+1, 4] = mapping[i, 1]\n        impropers_info_new[lmp_react1.improper_info[:, 5] == i+1, 5] = mapping[i, 1]\n\n    for i in range(len(impropers_info_new)):\n        impropers_info_new[i, 1] = 0\n        match = 0\n        for j in range(len(mapping_dict['mapping_impropers'])):\n            if (impropers_info_new[i, 2] == mapping_dict['mapping_impropers'][j, 0]) and np.all(np.sort(impropers_info_new[i, 3:]) == np.sort(mapping_dict['mapping_impropers'][j, 1:])):\n                impropers_info_new[i, 2] = lmp_react1.improper_info[i, 2]\n                impropers_info_new[i, 3] = lmp_react1.improper_info[i, 3]\n                impropers_info_new[i, 4] = lmp_react1.improper_info[i, 4]\n                impropers_info_new[i, 5] = lmp_react1.improper_info[i, 5]\n                impropers_info_new[i, 1] = j+1\n                match += 1\n        if match == 0:\n            impropers_info_new[i, 2] = lmp_react1.improper_info[i, 2]\n            impropers_info_new[i, 3] = lmp_react1.improper_info[i, 3]\n            impropers_info_new[i, 4] = lmp_react1.improper_info[i, 4]\n            impropers_info_new[i, 5] = lmp_react1.improper_info[i, 5]\n            impropers_info_new[i, 1] = mapping_dict['improper_coeff_new'][mapping_dict['improper_coeff_new'][:, 1] == 0, 0][0]\n            print(impropers_info_new[i])\n\n    print(np.sum(impropers_info_new[:, 1] == 0))\n\n    lmp_react_new = lammps(natoms=lmp_react1.natoms,\n                           natom_types=len(mapping_dict['mass_new']),\n                           nbonds=lmp_react1.nbonds,\n                           nbond_types=len(mapping_dict['bond_coeff_new']),\n                           nangles=lmp_react1.nangles,\n                           nangle_types=len(mapping_dict['angle_coeff_new']),\n                           ndihedrals=lmp_react1.ndihedrals,\n                           ndihedral_types=len(mapping_dict['dihedral_coeff_new']),\n                           nimpropers=lmp_react1.nimpropers,\n                           nimproper_types=len(mapping_dict['improper_coeff_new']),\n                           mass=mapping_dict['mass_new'],\n                           x=lmp_react1.x,\n                           y=lmp_react1.y,\n                           z=lmp_react1.z,\n                           pair_coeff=mapping_dict['pair_coeff_new'],\n                           bond_coeff=mapping_dict['bond_coeff_new'],\n                           angle_coeff=mapping_dict['angle_coeff_new'],\n                           dihedral_coeff=mapping_dict['dihedral_coeff_new'],\n                           improper_coeff=mapping_dict['improper_coeff_new'],\n                           atom_info=atom_info_new,\n                           bond_info=bond_info_new,\n                           angle_info=angle_info_new,\n                           dihedral_info=dihedral_info_new,\n                           improper_info=impropers_info_new)\n    return lmp_react_new\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.distance_pbc","title":"<code>distance_pbc(coord1, coord2, box)</code>","text":"<p>Compute pairwise distances under periodic boundary conditions.</p> <p>Parameters:</p> Name Type Description Default <code>coord1</code> <code>ndarray</code> <p>Array of shape <code>(N, 3)</code> with coordinates for <code>N</code> atoms.</p> required <code>coord2</code> <code>ndarray</code> <p>Array of shape <code>(M, 3)</code> with coordinates for <code>M</code> atoms.</p> required <code>box</code> <code>ndarray</code> <p><code>(3, 3)</code> matrix whose rows are the box vectors.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Distance matrix of shape <code>(N, M)</code> between <code>coord1</code> and <code>coord2</code>.</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def distance_pbc(coord1, coord2, box):\n    \"\"\"Compute pairwise distances under periodic boundary conditions.\n\n    Parameters\n    ----------\n    coord1 : numpy.ndarray\n        Array of shape ``(N, 3)`` with coordinates for ``N`` atoms.\n    coord2 : numpy.ndarray\n        Array of shape ``(M, 3)`` with coordinates for ``M`` atoms.\n    box : numpy.ndarray\n        ``(3, 3)`` matrix whose rows are the box vectors.\n\n    Returns\n    -------\n    numpy.ndarray\n        Distance matrix of shape ``(N, M)`` between ``coord1`` and ``coord2``.\n    \"\"\"\n    # Expand coord1 and coord2 to (N, 1, 3) and (1, M, 3) respectively to broadcast subtraction\n    delta = coord1[:, np.newaxis, :] - coord2[np.newaxis, :, :]\n\n    # Compute box inversions and apply periodic boundary conditions\n    delta -= np.round(delta @ np.linalg.inv(box)) @ box\n\n    # Compute the Euclidean distance\n    dist_matrix = np.linalg.norm(delta, axis=-1)\n\n    return dist_matrix\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.dump2str","title":"<code>dump2str(save_file, dump_file, sample_file, idx)</code>","text":"<p>Convert selected dump frames to a LAMMPS data structure file.</p> <p>Parameters:</p> Name Type Description Default <code>save_file</code> <code>str</code> <p>Destination for the generated structure file.</p> required <code>dump_file</code> <code>str</code> <p>Path to the <code>dump custom</code> trajectory.</p> required <code>sample_file</code> <code>str</code> <p>Reference LAMMPS data file used for topology and masses.</p> required <code>idx</code> <code>int or list[int]</code> <p>Frame index or indices to convert.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The converted structure is written to <code>save_file</code>.</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def dump2str(save_file: str,\n             dump_file: str,\n             sample_file: str,\n             idx: int or list):\n    \"\"\"Convert selected dump frames to a LAMMPS data structure file.\n\n    Parameters\n    ----------\n    save_file : str\n        Destination for the generated structure file.\n    dump_file : str\n        Path to the ``dump custom`` trajectory.\n    sample_file : str\n        Reference LAMMPS data file used for topology and masses.\n    idx : int or list[int]\n        Frame index or indices to convert.\n\n    Returns\n    -------\n    None\n        The converted structure is written to ``save_file``.\n    \"\"\"\n    lmp = read_lammps_full(sample_file)\n    lmp.atom_info = lmp.atom_info[np.argsort(lmp.atom_info[:, 0])]\n    frame_list, t_list, L_list = read_lammps_dump_custom(dump_file)\n    lmp_new = copy.copy(lmp)\n\n    if type(idx) == int:\n        idx = [idx]\n    for id in idx:\n        lmp_new.x = L_list[id][0]\n        lmp_new.y = L_list[id][1]\n        lmp_new.z = L_list[id][2]\n\n        coors = frame_list[id].loc[:, ['x', 'y', 'z']].values\n        lmp_new.atom_info[:, 4:7] = coors\n        write_lammps_full(save_file + f'{id}', lmp_new)\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.read_lammps_dump_custom","title":"<code>read_lammps_dump_custom(dump_file, interval=1)</code>","text":"<p>Read a LAMMPS <code>dump custom</code> trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>dump_file</code> <code>str</code> <p>Path to the dump file produced by LAMMPS.</p> required <code>interval</code> <code>int</code> <p>Step interval between stored frames.</p> <code>1</code> <p>Returns:</p> Type Description <code>tuple[list[ndarray], list[int], list[ndarray]]</code> <p>Parsed coordinate frames, timesteps and box bounds for each frame.</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def read_lammps_dump_custom(dump_file, interval=1):\n    \"\"\"Read a LAMMPS ``dump custom`` trajectory.\n\n    Parameters\n    ----------\n    dump_file : str\n        Path to the dump file produced by LAMMPS.\n    interval : int, default 1\n        Step interval between stored frames.\n\n    Returns\n    -------\n    tuple[list[numpy.ndarray], list[int], list[numpy.ndarray]]\n        Parsed coordinate frames, timesteps and box bounds for each frame.\n    \"\"\"\n    t_list = []\n    frame = []\n    L_list = []\n    frame_count = 0\n\n    with open(dump_file, 'r') as f:\n        for line in f:\n            if line.startswith('ITEM: TIMESTEP'):\n                frame_count += 1\n                timestep = int(next(f).split()[0])\n\n                # Only process and store the frame if frame_count is a multiple of the interval\n                if frame_count % interval == 0:\n                    t_list.append(timestep)\n                    store_frame = True\n                else:\n                    store_frame = False\n\n            if line.startswith('ITEM: NUMBER OF ATOMS') and store_frame:\n                natoms = int(next(f).split()[0])\n\n            if line.startswith('ITEM: BOX') and store_frame:\n                lx = [float(x) for x in next(f).split()[:2]]\n                ly = [float(x) for x in next(f).split()[:2]]\n                lz = [float(x) for x in next(f).split()[:2]]\n                L_list.append([lx, ly, lz])\n\n            if line.startswith('ITEM: ATOMS') and store_frame:\n                columns = line.split()[2:]\n                data = []\n                for i in range(natoms):\n                    line_data = []\n                    raw_fields = [x for x in next(f).split() if x.strip()]\n                    for x in raw_fields[:len(columns)]:\n                        try:\n                            line_data.append(float(x))\n                        except ValueError:\n                            line_data.append(str(x))\n                    data.append(line_data)\n                    # data.append([float(x) for x in next(f).split()])\n                df = pd.DataFrame(data, columns=columns)\n                df_sorted = df.sort_values(by=['id'])\n                frame.append(df_sorted)\n\n    return frame, t_list, L_list\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.read_log_lammps","title":"<code>read_log_lammps(logfile, freq=1)</code>","text":"<p>Read a LAMMPS log file into per-block data frames.</p> <p>Parameters:</p> Name Type Description Default <code>logfile</code> <code>str</code> <p>Path to <code>log.lammps</code>.</p> required <code>freq</code> <code>int</code> <p>Sampling frequency for the returned data.</p> <code>1</code> <p>Returns:</p> Type Description <code>list[DataFrame]</code> <p>Thermodynamic blocks parsed from the log file.</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def read_log_lammps(logfile, freq=1):\n    \"\"\"Read a LAMMPS log file into per-block data frames.\n\n    Parameters\n    ----------\n    logfile : str\n        Path to ``log.lammps``.\n    freq : int, default 1\n        Sampling frequency for the returned data.\n\n    Returns\n    -------\n    list[pandas.DataFrame]\n        Thermodynamic blocks parsed from the log file.\n    \"\"\"\n    f = open(logfile, 'r')\n    L = f.readlines()\n    f.close()\n    l1_list, l2_list = [], []\n    for i in range(len(L)):\n        if ('Step' in L[i]) and ('Temp' in L[i]):\n            l1_list.append(i)\n        if 'Loop time' in L[i]:\n            l2_list.append(i)\n    if len(l2_list) == 0:\n        l2_list.append(len(L)-1)\n    # print(l1_list, l2_list)\n    data_list = []\n    for i, l1 in enumerate(l1_list):\n        l2 = l2_list[i]\n        data = np.array(L[l1+1].split())\n        for i in range(l1+1, l2, freq):\n            data = np.vstack((data, L[i].split()))\n        data = pd.DataFrame(data, dtype='float64', columns=L[l1].split())\n        data_list.append(data)\n    return data_list\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.read_table_pot","title":"<code>read_table_pot(file_name, key_words)</code>","text":"<p>Read a LAMMPS table potential block.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Path to the table potential file.</p> required <code>key_words</code> <code>str</code> <p>Keyword marking the start of the desired table section.</p> required <p>Returns:</p> Type Description <code>tuple[list[float], list[float], list[float]]</code> <p>Radial positions, potential energies and forces from the table.</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def read_table_pot(file_name, key_words):\n    \"\"\"Read a LAMMPS table potential block.\n\n    Parameters\n    ----------\n    file_name : str\n        Path to the table potential file.\n    key_words : str\n        Keyword marking the start of the desired table section.\n\n    Returns\n    -------\n    tuple[list[float], list[float], list[float]]\n        Radial positions, potential energies and forces from the table.\n    \"\"\"\n    r = []\n    e_pot = []\n    f_pot = []\n    with open(file_name, 'r') as f:\n        while True:\n            line = f.readline()\n            if key_words in line:\n                meta_info = f.readline()\n                f.readline()\n                for i in range(int(meta_info.split()[1])):\n                    line = f.readline()\n                    data = line.split()\n                    r.append(float(data[1]))\n                    e_pot.append(float(data[2]))\n                    f_pot.append(float(data[3]))\n                break\n    r = np.array(r)\n    e_pot = np.array(e_pot)\n    f_pot = np.array(f_pot)\n    return r, e_pot, f_pot\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.wrap_mol","title":"<code>wrap_mol(save_file, input_file)</code>","text":"<p>Wrap molecules into the primary box while preserving connectivity.</p> <p>Parameters:</p> Name Type Description Default <code>save_file</code> <code>str</code> <p>Base path for the wrapped output file.</p> required <code>input_file</code> <code>str</code> <p>LAMMPS data file containing molecule ids and coordinates.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The wrapped structure is written with the <code>save_file</code> prefix.</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def wrap_mol(save_file: str,\n             input_file: str):\n    \"\"\"Wrap molecules into the primary box while preserving connectivity.\n\n    Parameters\n    ----------\n    save_file : str\n        Base path for the wrapped output file.\n    input_file : str\n        LAMMPS data file containing molecule ids and coordinates.\n\n    Returns\n    -------\n    None\n        The wrapped structure is written with the ``save_file`` prefix.\n    \"\"\"\n\n    lmp = read_lammps_full(input_file)\n    lmp.atom_info = lmp.atom_info[np.argsort(lmp.atom_info[:, 0])]\n    lmp_new = copy.copy(lmp)\n    box_size = lmp.x[1] - lmp.x[0]  # assume cubic for now\n\n    mol_id = lmp.atom_info[:, 1]\n    mol_list = np.unique(mol_id)\n\n    for mol in mol_list:\n        idx = np.argwhere(mol_id == mol).flatten()\n        coors = lmp.atom_info[idx, 4:7]\n        rcoors = coors - coors[0]\n        rcoors = rcoors - np.round(rcoors/box_size)*box_size\n        coors = coors[0] + rcoors\n        lmp_new.atom_info[idx, 4:7] = coors\n\n    write_lammps_full(save_file, lmp_new)\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.write_lammps","title":"<code>write_lammps(file_name, lmp_tmp, mode='full')</code>","text":"<p>Write a LAMMPS data file from an in-memory structure.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Path to the output LAMMPS data file.</p> required <code>lmp_tmp</code> <code>lammps</code> <p>LAMMPS object containing box bounds, atom data, masses and optional potential coefficients.</p> required <code>mode</code> <code>(full, atomic)</code> <p>Atom style used when writing the <code>Atoms</code> section.</p> <code>\"full\"</code> <p>Returns:</p> Type Description <code>None</code> <p>The data file is written to <code>file_name</code>.</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def write_lammps(file_name, lmp_tmp, mode='full'):\n    \"\"\"Write a LAMMPS data file from an in-memory structure.\n\n    Parameters\n    ----------\n    file_name : str\n        Path to the output LAMMPS data file.\n    lmp_tmp : lammps\n        LAMMPS object containing box bounds, atom data, masses and optional\n        potential coefficients.\n    mode : {\"full\", \"atomic\"}, default \"full\"\n        Atom style used when writing the ``Atoms`` section.\n\n    Returns\n    -------\n    None\n        The data file is written to ``file_name``.\n    \"\"\"\n    with open('{}'.format(file_name), 'w') as f:\n        f.write('Generated by ZYMD\\n\\n')\n\n        f.write('{} atoms\\n'.format(lmp_tmp.natoms))\n        f.write('{} atom types\\n'.format(lmp_tmp.natom_types))\n        f.write('{} bonds\\n'.format(lmp_tmp.nbonds))\n        f.write('{} bond types\\n'.format(lmp_tmp.nbond_types))\n        f.write('{} angles\\n'.format(lmp_tmp.nangles))\n        f.write('{} angle types\\n'.format(lmp_tmp.nangle_types))\n        f.write('{} dihedrals\\n'.format(lmp_tmp.ndihedrals))\n        f.write('{} dihedral types\\n'.format(lmp_tmp.ndihedral_types))\n        f.write('{} impropers\\n'.format(lmp_tmp.nimpropers))\n        f.write('{} improper types\\n'.format(lmp_tmp.nimproper_types))\n        f.write('\\n')\n\n        f.write('{0:.16f} {1:.16f} xlo xhi\\n'.format(lmp_tmp.x[0], lmp_tmp.x[1]))\n        f.write('{0:.16f} {1:.16f} ylo yhi\\n'.format(lmp_tmp.y[0], lmp_tmp.y[1]))\n        f.write('{0:.16f} {1:.16f} zlo zhi\\n'.format(lmp_tmp.z[0], lmp_tmp.z[1]))\n        f.write('\\n')\n\n        f.write('Masses\\n\\n')\n        for i in range(len(lmp_tmp.mass)):\n            if lmp_tmp.mass.shape[1] == 3:\n                f.write('{0:d} {1:.3f} # {2:s}\\n'.format(\n                    int(float(lmp_tmp.mass[i, 0])), float(lmp_tmp.mass[i, 1]), lmp_tmp.mass[i, 2]))\n            elif lmp_tmp.mass.shape[1] == 2:\n                f.write('{0:d} {1:.3f}\\n'.format(\n                    int(float(lmp_tmp.mass[i, 0])), float(lmp_tmp.mass[i, 1])))\n        f.write('\\n')\n\n        if hasattr(lmp_tmp, 'pair_coeff') and not (lmp_tmp.pair_coeff is None):\n            f.write('Pair Coeffs\\n\\n')\n            for i in range(len(lmp_tmp.pair_coeff)):\n                f.write('{0:d} {1:f} {2:f}\\n'.format(\n                    int(lmp_tmp.pair_coeff[i, 0]), lmp_tmp.pair_coeff[i, 1], lmp_tmp.pair_coeff[i, 2]))\n            f.write('\\n')\n\n        if hasattr(lmp_tmp, 'bond_coeff') and not (lmp_tmp.bond_coeff is None):\n            f.write('Bond Coeffs\\n\\n')\n            for i in range(len(lmp_tmp.bond_coeff)):\n                f.write('{0:d} {1:f} {2:f}\\n'.format(\n                    int(lmp_tmp.bond_coeff[i, 0]), lmp_tmp.bond_coeff[i, 1], lmp_tmp.bond_coeff[i, 2]))\n            f.write('\\n')\n\n        if hasattr(lmp_tmp, 'angle_coeff') and not (lmp_tmp.angle_coeff is None):\n            f.write('Angle Coeffs\\n\\n')\n            for i in range(len(lmp_tmp.angle_coeff)):\n                f.write('{0:d} {1:f} {2:f}\\n'.format(\n                    int(lmp_tmp.angle_coeff[i, 0]), lmp_tmp.angle_coeff[i, 1], lmp_tmp.angle_coeff[i, 2]))\n            f.write('\\n')\n\n        if hasattr(lmp_tmp, 'dihedral_coeff') and not (lmp_tmp.dihedral_coeff is None):\n            f.write('Dihedral Coeffs\\n\\n')\n            for i in range(len(lmp_tmp.dihedral_coeff)):\n                f.write('{0:d} {1:f} {2:f} {3:f} {4:f}\\n'.format(int(lmp_tmp.dihedral_coeff[i, 0]), lmp_tmp.dihedral_coeff[i, 1], lmp_tmp.dihedral_coeff[i, 2],\n                                                                 lmp_tmp.dihedral_coeff[i, 3], lmp_tmp.dihedral_coeff[i, 4]))\n            f.write('\\n')\n\n        if hasattr(lmp_tmp, 'improper_coeff') and not (lmp_tmp.improper_coeff is None):\n            f.write('Improper Coeffs\\n\\n')\n            for i in range(len(lmp_tmp.improper_coeff)):\n                f.write('{0:d} {1:f} {2:d} {3:d}\\n'.format(int(lmp_tmp.improper_coeff[i, 0]), lmp_tmp.improper_coeff[i, 1], int(lmp_tmp.improper_coeff[i, 2]),\n                                                           int(lmp_tmp.improper_coeff[i, 3])))\n            f.write('\\n')\n\n        # f.write('Atoms\\n\\n')\n        # for i in range(len(lmp_tmp.atom_info)):\n        #     if lmp_tmp.atom_info.shape[1] &gt; 7:\n        #         f.write('{0:d} {1:d} {2:d} {3:f} {4:f} {5:f} {6:f} {8:d} {7:d} {9:d}\\n'.format(int(lmp_tmp.atom_info[i, 0]), int(lmp_tmp.atom_info[i, 1]), int(lmp_tmp.atom_info[i, 2]),\n        #            lmp_tmp.atom_info[i, 3], lmp_tmp.atom_info[i, 4], lmp_tmp.atom_info[i, 5], lmp_tmp.atom_info[i, 6], int(lmp_tmp.atom_info[i, 7]), int(lmp_tmp.atom_info[i, 8]), int(lmp_tmp.atom_info[i, 9])))\n        #     else:\n        #         f.write('{0:d} {1:d} {2:d} {3:f} {4:f} {5:f} {6:f}\\n'.format(int(lmp_tmp.atom_info[i, 0]), int(lmp_tmp.atom_info[i, 1]), int(lmp_tmp.atom_info[i, 2]),\n        #              lmp_tmp.atom_info[i, 3], lmp_tmp.atom_info[i, 4], lmp_tmp.atom_info[i, 5], lmp_tmp.atom_info[i, 6]))\n        # f.write('\\n')\n\n        f.write('Atoms\\n\\n')\n        lmp_tmp.atom_info = lmp_tmp.atom_info.astype(object)\n        lmp_tmp.atom_info[:, 0] = lmp_tmp.atom_info[:, 0].astype(int)\n        lmp_tmp.atom_info[:, 1] = lmp_tmp.atom_info[:, 1].astype(int)\n        if mode=='full':\n            lmp_tmp.atom_info[:, 2] = lmp_tmp.atom_info[:, 2].astype(int)\n        for row in lmp_tmp.atom_info:\n            line = []\n            for val in row:\n                if isinstance(val, float) or (isinstance(val, np.float64) or isinstance(val, np.float32)):\n                    line.append(f'{val:.6f}')\n                else:\n                    line.append(f'{int(val)}')\n            f.write(' '.join(line) + '\\n')\n        f.write('\\n')\n\n        if hasattr(lmp_tmp, 'velocity_info') and not (lmp_tmp.velocity_info is None):\n            f.write('Velocities \\n\\n')\n            for i in range(len(lmp_tmp.velocity_info)):\n                f.write('{0:d} {1:f} {2:f} {3:f}\\n'.format(int(\n                    lmp_tmp.velocity_info[i, 0]), lmp_tmp.velocity_info[i, 1], lmp_tmp.velocity_info[i, 2], lmp_tmp.velocity_info[i, 3]))\n            f.write('\\n')\n\n        if hasattr(lmp_tmp, 'bond_info') and not (lmp_tmp.bond_info is None) and not (lmp_tmp.nbonds == 0):\n            f.write('Bonds\\n\\n')\n            for i in range(len(lmp_tmp.bond_info)):\n                f.write('{0:d} {1:d} {2:d} {3:d}\\n'.format(int(lmp_tmp.bond_info[i, 0]), int(\n                    lmp_tmp.bond_info[i, 1]), int(lmp_tmp.bond_info[i, 2]), int(lmp_tmp.bond_info[i, 3])))\n            f.write('\\n')\n\n        if hasattr(lmp_tmp, 'angle_info') and not (lmp_tmp.angle_info is None) and not (lmp_tmp.nangles == 0):\n            f.write('Angles\\n\\n')\n            for i in range(len(lmp_tmp.angle_info)):\n                f.write('{0:d} {1:d} {2:d} {3:d} {4:d}\\n'.format(int(lmp_tmp.angle_info[i, 0]), int(lmp_tmp.angle_info[i, 1]), int(lmp_tmp.angle_info[i, 2]),\n                                                                 int(lmp_tmp.angle_info[i, 3]), int(lmp_tmp.angle_info[i, 4])))\n            f.write('\\n')\n\n        if hasattr(lmp_tmp, 'dihedral_info') and not (lmp_tmp.dihedral_info is None) and not (lmp_tmp.ndihedrals == 0):\n            f.write('Dihedrals\\n\\n')\n            for i in range(len(lmp_tmp.dihedral_info)):\n                f.write('{0:d} {1:d} {2:d} {3:d} {4:d} {5:d}\\n'.format(int(lmp_tmp.dihedral_info[i, 0]), int(lmp_tmp.dihedral_info[i, 1]), int(lmp_tmp.dihedral_info[i, 2]),\n                                                                       int(lmp_tmp.dihedral_info[i, 3]), int(lmp_tmp.dihedral_info[i, 4]), int(lmp_tmp.dihedral_info[i, 5])))\n            f.write('\\n')\n\n        if hasattr(lmp_tmp, 'improper_info') and not (lmp_tmp.improper_info is None) and not (lmp_tmp.nimpropers == 0):\n            f.write('Impropers\\n\\n')\n            for i in range(len(lmp_tmp.improper_info)):\n                f.write('{0:d} {1:d} {2:d} {3:d} {4:d} {5:d}\\n'.format(int(lmp_tmp.improper_info[i, 0]), int(lmp_tmp.improper_info[i, 1]), int(lmp_tmp.improper_info[i, 2]),\n                                                                       int(lmp_tmp.improper_info[i, 3]), int(lmp_tmp.improper_info[i, 4]), int(lmp_tmp.improper_info[i, 5])))\n            f.write('\\n')\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.write_lammps_atomic","title":"<code>write_lammps_atomic(file_name, lmp_tmp)</code>","text":"<p>Write an atomic-style LAMMPS data file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Destination path for the data file.</p> required <code>lmp_tmp</code> <code>lammps</code> <p>LAMMPS object containing atomic coordinates and masses.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The data file is written to <code>file_name</code>.</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def write_lammps_atomic(file_name, lmp_tmp):\n    \"\"\"Write an atomic-style LAMMPS data file.\n\n    Parameters\n    ----------\n    file_name : str\n        Destination path for the data file.\n    lmp_tmp : lammps\n        LAMMPS object containing atomic coordinates and masses.\n\n    Returns\n    -------\n    None\n        The data file is written to ``file_name``.\n    \"\"\"\n    with open('{}'.format(file_name), 'w') as f:\n        f.write('Generated by ZY code\\n\\n')\n\n        f.write('{} atoms\\n'.format(lmp_tmp.natoms))\n        f.write('{} atom types\\n'.format(lmp_tmp.natom_types))\n        f.write('\\n')\n\n        f.write('{0:.16f} {1:.16f} xlo xhi\\n'.format(lmp_tmp.x[0], lmp_tmp.x[1]))\n        f.write('{0:.16f} {1:.16f} ylo yhi\\n'.format(lmp_tmp.y[0], lmp_tmp.y[1]))\n        f.write('{0:.16f} {1:.16f} zlo zhi\\n'.format(lmp_tmp.z[0], lmp_tmp.z[1]))\n        f.write('\\n')\n\n        f.write('Masses\\n\\n')\n        for i in range(len(lmp_tmp.mass)):\n            if lmp_tmp.mass.shape[1] == 3:\n                f.write('{0:d} {1:.3f} # {2:s}\\n'.format(\n                    int(float(lmp_tmp.mass[i, 0])), float(lmp_tmp.mass[i, 1]), lmp_tmp.mass[i, 2]))\n            elif lmp_tmp.mass.shape[1] == 2:\n                f.write('{0:d} {1:.3f}\\n'.format(\n                    int(float(lmp_tmp.mass[i, 0])), float(lmp_tmp.mass[i, 1])))\n        f.write('\\n')\n\n        f.write('Atoms # full\\n\\n')\n        for i in range(len(lmp_tmp.atom_info)):\n            if lmp_tmp.atom_info.shape[1] &gt; 7:\n                f.write('{0:d} {1:d} {2:f} {3:f} {4:f}\\n'.format(int(lmp_tmp.atom_info[i, 0]), int(lmp_tmp.atom_info[i, 2]), lmp_tmp.atom_info[i, 4], lmp_tmp.atom_info[i, 5], lmp_tmp.atom_info[i, 6]))\n        f.write('\\n')\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.write_lammps_dump_custom","title":"<code>write_lammps_dump_custom(file_name, frame, t_list, L_list)</code>","text":"<p>Write <code>dump custom</code> data from in-memory frames.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Output path for the dump file.</p> required <code>frame</code> <code>list[DataFrame]</code> <p>Per-frame atom data sorted by id.</p> required <code>t_list</code> <code>list[int]</code> <p>Timesteps corresponding to each frame.</p> required <code>L_list</code> <code>list[ndarray]</code> <p>Box bounds for each frame as <code>(3, 2)</code> arrays.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The combined dump is written to <code>file_name</code>.</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def write_lammps_dump_custom(file_name, frame, t_list, L_list):\n    \"\"\"Write ``dump custom`` data from in-memory frames.\n\n    Parameters\n    ----------\n    file_name : str\n        Output path for the dump file.\n    frame : list[pandas.DataFrame]\n        Per-frame atom data sorted by id.\n    t_list : list[int]\n        Timesteps corresponding to each frame.\n    L_list : list[numpy.ndarray]\n        Box bounds for each frame as ``(3, 2)`` arrays.\n\n    Returns\n    -------\n    None\n        The combined dump is written to ``file_name``.\n    \"\"\"\n    f = open('{}'.format(file_name), 'w')\n    for it in range(len(t_list)):\n        f.write('ITEM: TIMESTEP\\n')\n        f.write('{}\\n'.format(t_list[it]))\n        f.write('ITEM: NUMBER OF ATOMS\\n')\n        f.write('{}\\n'.format(len(frame[it])))\n        f.write('ITEM: BOX BOUNDS pp pp pp\\n')\n        for i in range(3):\n            f.write('{} {}\\n'.format(L_list[it][i][0], L_list[it][i][1]))\n        f.write('ITEM: ATOMS ')\n        for col in frame[it].columns:\n            f.write('{} '.format(col))\n        f.write('\\n')\n        for i in range(len(frame[it])):\n            f.write('{} '.format(int(frame[it].iloc[i, 0])))\n            for j in range(1, len(frame[it].columns)):\n                # if integer, write as int, otherwise as float\n                if isinstance(frame[it].iloc[i, j], int):\n                    f.write('{0:d} '.format(int(frame[it].iloc[i, j])))\n                else:\n                    f.write('{0:.6f} '.format(frame[it].iloc[i, j]))\n            f.write('\\n')\n    f.close()\n</code></pre>"},{"location":"references/other/","title":"Other","text":"<p>A collection of common functions for basic MD process: supercell, read and write POSCAR, PDF, XYZ, progressbar, replace_in_file, read_ORCA</p> <p>Tools for reading and writing .gro files</p>"},{"location":"references/other/#m2dtools.other.common.evaluate_linear_fit_np","title":"<code>evaluate_linear_fit_np(x, y)</code>","text":"<p>Evaluate a simple linear fit.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Independent variable values.</p> required <code>y</code> <code>ndarray</code> <p>Dependent variable values.</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>Coefficient of determination (R^2) and mean squared error.</p> Source code in <code>m2dtools/other/common.py</code> <pre><code>def evaluate_linear_fit_np(x, y):\n    \"\"\"Evaluate a simple linear fit.\n\n    Parameters\n    ----------\n    x : numpy.ndarray\n        Independent variable values.\n    y : numpy.ndarray\n        Dependent variable values.\n\n    Returns\n    -------\n    tuple[float, float]\n        Coefficient of determination (R^2) and mean squared error.\n    \"\"\"\n    # Fit a linear model\n    coefficients = np.polyfit(x, y, 1)\n    polynomial = np.poly1d(coefficients)\n\n    # Predict y values\n    y_pred = polynomial(x)\n\n    # Calculate R2 score\n    ss_res = np.sum((y - y_pred) ** 2)  # MSE\n    ss_tot = np.sum((y - np.mean(y)) ** 2)\n    r2 = 1 - (ss_res / ss_tot)\n\n    return r2, np.sqrt(ss_res)\n</code></pre>"},{"location":"references/other/#m2dtools.other.common.pdf_sq_1type","title":"<code>pdf_sq_1type(box, natom, type_atom, coors, r_cutoff=10, delta_r=0.01)</code>","text":"<p>Compute pair distribution and structure factors for a single species.</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>ndarray</code> <p>Simulation box matrix.</p> required <code>natom</code> <code>int</code> <p>Total number of atoms.</p> required <code>type_atom</code> <code>array - like</code> <p>Atom type identifiers.</p> required <code>coors</code> <code>ndarray</code> <p>Cartesian coordinates.</p> required <code>r_cutoff</code> <code>float</code> <p>Maximum distance for the radial distribution function.</p> <code>10</code> <code>delta_r</code> <code>float</code> <p>Bin width for the radial distribution function.</p> <code>0.01</code> <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray, ndarray, ndarray]</code> <p>Radial positions, pair distribution function, q values and structure factor for the single-species system.</p> Source code in <code>m2dtools/other/common.py</code> <pre><code>def pdf_sq_1type(box, natom, type_atom, coors, r_cutoff=10, delta_r=0.01):\n    \"\"\"Compute pair distribution and structure factors for a single species.\n\n    Parameters\n    ----------\n    box : numpy.ndarray\n        Simulation box matrix.\n    natom : int\n        Total number of atoms.\n    type_atom : array-like\n        Atom type identifiers.\n    coors : numpy.ndarray\n        Cartesian coordinates.\n    r_cutoff : float, default 10\n        Maximum distance for the radial distribution function.\n    delta_r : float, default 0.01\n        Bin width for the radial distribution function.\n\n    Returns\n    -------\n    tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray]\n        Radial positions, pair distribution function, q values and structure\n        factor for the single-species system.\n    \"\"\"\n    type_atom = np.array(type_atom)\n    n1 = natom\n    rcoors = np.dot(coors, np.linalg.inv(box))\n    rdis = np.zeros([natom, natom, 3])\n    for i in range(natom):\n        tmp = rcoors[i]\n        rdis[i, :, :] = tmp - rcoors\n    rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5] + 1\n    rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5] - 1\n    a = np.dot(rdis[:, :, :], box)\n    dis = np.sqrt((np.square(a[:, :, 0]) + np.square(a[:, :, 1]) + np.square(a[:, :, 2])))\n    r_max = r_cutoff\n    r = np.linspace(delta_r, r_max, int(r_max / delta_r))\n    V = np.dot(np.cross(box[1, :], box[2, :]), box[0, :])\n    rho1 = n1 / V\n    c = np.array([rho1 * rho1]) * V\n    g1 = np.histogram(dis[:n1, :n1], bins=r)[0] / (4 * np.pi * (r[1:] - delta_r / 2) ** 2 * delta_r * c[0])\n    R = r[1:] - delta_r / 2\n\n    dq = 0.01\n    qrange = [np.pi / 2 / r_max, 25]\n    Q = np.arange(np.floor(qrange[0] / dq), np.floor(qrange[1] / dq), 1) * dq\n    S1 = np.zeros([len(Q)])\n    rho = natom / np.dot(np.cross(box[1, :], box[2, :]), box[0, :]) / 10 ** 3\n    # use a window function for fourier transform\n    for i in np.arange(len(Q)):\n        S1[i] = 1 + 4 * np.pi * rho / Q[i] * np.trapz(\n            (g1 - 1) * np.sin(Q[i] * R) * R * np.sin(np.pi * R / r_max) / (np.pi * R / r_max), R)\n\n    return R, g1, Q, S1\n</code></pre>"},{"location":"references/other/#m2dtools.other.common.read_pos","title":"<code>read_pos(file_name)</code>","text":"<p>Read a VASP POSCAR structure.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Path to the POSCAR file.</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray, ndarray, ndarray]</code> <p>Box matrix, atomic species, species counts and Cartesian coordinates.</p> Source code in <code>m2dtools/other/common.py</code> <pre><code>def read_pos(file_name):\n    \"\"\"Read a VASP POSCAR structure.\n\n    Parameters\n    ----------\n    file_name : str\n        Path to the POSCAR file.\n\n    Returns\n    -------\n    tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray]\n        Box matrix, atomic species, species counts and Cartesian coordinates.\n    \"\"\"\n    f = open(file_name, 'r')\n    lf = list(f)\n    f.close()\n    box = np.zeros((3, 3))\n    ratio = float(lf[1].split()[0])\n    box[0, :] = np.array(lf[2].split()).astype(float)*ratio\n    box[1, :] = np.array(lf[3].split()).astype(float)*ratio\n    box[2, :] = np.array(lf[4].split()).astype(float)*ratio\n    a_type = np.array(lf[5].split())\n    num_type = np.array(lf[6].split()).astype(int)\n\n    natom = np.sum(num_type)\n    coors = np.zeros((natom, 3))\n\n    if lf[7].split()[0][0] == 'C' or lf[7].split()[0][0] == 'c':\n        print('Cartesian coordinates detected in POSCAR.')\n        l = 0\n        for ia in lf[8:8+natom]:\n            coors[l, :] = np.array(ia.split()[0:3:1]).astype('float')\n            l += 1\n\n    if lf[7].split()[0][0] == 'D' or lf[7].split()[0][0] == 'd':\n        l = 0\n        rcoors = np.zeros((natom, 3))\n        for ia in lf[8:8+natom]:\n            rcoors[l, :] = np.array(ia.split()[0:3:1]).astype('float')\n            l += 1\n        coors = rcoors @ box\n    else:\n        print('Error: only Cartesian or Direct coordinates are supported in POSCAR!')\n\n    return box, a_type, num_type, coors\n</code></pre>"},{"location":"references/other/#m2dtools.other.common.read_xyz_simple","title":"<code>read_xyz_simple(filename)</code>","text":"<p>Read an extended XYZ file. Returns:     types  : (N,) array of strings     coords : (N,3) float array     lattice: (3,3) float array  (box matrix)</p> Source code in <code>m2dtools/other/common.py</code> <pre><code>def read_xyz_simple(filename):\n    \"\"\"\n    Read an extended XYZ file.\n    Returns:\n        types  : (N,) array of strings\n        coords : (N,3) float array\n        lattice: (3,3) float array  (box matrix)\n    \"\"\"\n    with open(filename, \"r\") as f:\n        # --- first line: number of atoms ---\n        natoms = int(f.readline().strip())\n\n        # --- second line: comment, possibly containing Lattice=\"...\" ---\n        comment = f.readline().strip()\n\n        # --- parse Lattice=\"...\" if present ---\n        lattice = np.eye(3)\n        m = re.search(r'Lattice=\"([^\"]+)\"', comment)\n        if m:\n            nums = list(map(float, m.group(1).split()))\n            if len(nums) != 9:\n                raise ValueError(\"Lattice must contain 9 numbers.\")\n            lattice = np.array(nums).reshape(3, 3)\n\n        # --- read atoms ---\n        types = []\n        coords = []\n        for _ in range(natoms):\n            line = f.readline().strip()\n            if not line:\n                raise ValueError(\"Unexpected EOF while reading atoms.\")\n\n            parts = line.split()\n            if len(parts) &lt; 4:\n                continue\n\n            types.append(parts[0])\n            coords.append([float(parts[1]), float(parts[2]), float(parts[3])])\n\n    return np.array(types), np.array(coords, float), lattice\n</code></pre>"},{"location":"references/other/#m2dtools.other.common.replace_in_file","title":"<code>replace_in_file(file_path_old, file_path_new, old_string, new_string)</code>","text":"<p>Replace text within a file and write the updated copy.</p> <p>Parameters:</p> Name Type Description Default <code>file_path_old</code> <code>str</code> <p>Source file to read.</p> required <code>file_path_new</code> <code>str</code> <p>Destination path for the updated content.</p> required <code>old_string</code> <code>str</code> <p>Text to be replaced.</p> required <code>new_string</code> <code>str</code> <p>Replacement text.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Writes <code>file_path_new</code> with updated contents.</p> Source code in <code>m2dtools/other/common.py</code> <pre><code>def replace_in_file(file_path_old, file_path_new, old_string, new_string):\n    \"\"\"Replace text within a file and write the updated copy.\n\n    Parameters\n    ----------\n    file_path_old : str\n        Source file to read.\n    file_path_new : str\n        Destination path for the updated content.\n    old_string : str\n        Text to be replaced.\n    new_string : str\n        Replacement text.\n\n    Returns\n    -------\n    None\n        Writes ``file_path_new`` with updated contents.\n    \"\"\"\n    try:\n        # Read the content of the file\n        with open(file_path_old, 'r') as file:\n            content = file.read()\n\n        # Replace old_string with new_string\n        modified_content = content.replace(old_string, new_string)\n\n        # Write the modified content back to the file\n        with open(file_path_new, 'w') as file:\n            file.write(modified_content)\n\n        print(\"File updated successfully.\")\n    except IOError as e:\n        print(f\"An error occurred: {e}\")\n</code></pre>"},{"location":"references/other/#m2dtools.other.common.supercell","title":"<code>supercell(natoms, box0, nx, ny, nz, index0, atom_type0, coors0)</code>","text":"<p>Build a replicated supercell from an orthogonal unit cell.</p> <p>Parameters:</p> Name Type Description Default <code>natoms</code> <code>int</code> <p>Number of atoms in the original cell.</p> required <code>box0</code> <code>ndarray</code> <p><code>(3, 3)</code> box matrix for the original cell.</p> required <code>nx</code> <code>int</code> <p>Replication counts along each lattice vector.</p> required <code>ny</code> <code>int</code> <p>Replication counts along each lattice vector.</p> required <code>nz</code> <code>int</code> <p>Replication counts along each lattice vector.</p> required <code>index0</code> <code>ndarray</code> <p>Atom indices for the original cell.</p> required <code>atom_type0</code> <code>ndarray</code> <p>Atom types for the original cell.</p> required <code>coors0</code> <code>ndarray</code> <p>Cartesian coordinates for the original cell.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p><code>(natoms_new, box_new, index_new, atom_type_new, coors_new)</code> for the replicated supercell.</p> Source code in <code>m2dtools/other/common.py</code> <pre><code>def supercell(natoms, box0, nx, ny, nz, index0, atom_type0, coors0):\n    \"\"\"Build a replicated supercell from an orthogonal unit cell.\n\n    Parameters\n    ----------\n    natoms : int\n        Number of atoms in the original cell.\n    box0 : numpy.ndarray\n        ``(3, 3)`` box matrix for the original cell.\n    nx, ny, nz : int\n        Replication counts along each lattice vector.\n    index0 : numpy.ndarray\n        Atom indices for the original cell.\n    atom_type0 : numpy.ndarray\n        Atom types for the original cell.\n    coors0 : numpy.ndarray\n        Cartesian coordinates for the original cell.\n\n    Returns\n    -------\n    tuple\n        ``(natoms_new, box_new, index_new, atom_type_new, coors_new)`` for the\n        replicated supercell.\n    \"\"\"\n\n    box_new = box0@np.array([[nx, 0, 0], [0, ny, 0], [0, 0, nz]])\n    natoms_new = natoms*nx*ny*nz\n\n    # coors_new = np.empty([1,3])\n    # index_new = np.empty\n\n    for ix in range(nx):\n        for iy in range(ny):\n            for iz in range(nz):\n                if ix+iy+iz == 0:\n                    coors_new = coors0\n                    atom_type_new = atom_type0\n                    index_new = index0\n                    index_tmp = index0\n                else:\n                    coors_tmp = coors0 + ix*box0[0, :] + iy*box0[1, :] + iz*box0[2, :]\n                    coors_new = np.vstack((coors_new, coors_tmp))\n\n                    atom_type_new = np.concatenate((atom_type_new, atom_type0))\n                    index_tmp = index_tmp + natoms\n                    index_new = np.concatenate((index_new, index_tmp))\n\n    return natoms_new, box_new, index_new, atom_type_new, coors_new\n</code></pre>"},{"location":"references/other/#m2dtools.other.common.write_pos","title":"<code>write_pos(file_name, box, a_type, num_type, coors)</code>","text":"<p>Write a VASP POSCAR structure.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Destination POSCAR path.</p> required <code>box</code> <code>ndarray</code> <p><code>(3, 3)</code> lattice matrix.</p> required <code>a_type</code> <code>array - like</code> <p>Sequence of element symbols.</p> required <code>num_type</code> <code>array - like</code> <p>Number of atoms for each element.</p> required <code>coors</code> <code>ndarray</code> <p>Cartesian coordinates for all atoms.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The POSCAR file is written to <code>file_name</code>.</p> Source code in <code>m2dtools/other/common.py</code> <pre><code>def write_pos(file_name, box, a_type, num_type, coors):\n    \"\"\"Write a VASP POSCAR structure.\n\n    Parameters\n    ----------\n    file_name : str\n        Destination POSCAR path.\n    box : numpy.ndarray\n        ``(3, 3)`` lattice matrix.\n    a_type : array-like\n        Sequence of element symbols.\n    num_type : array-like\n        Number of atoms for each element.\n    coors : numpy.ndarray\n        Cartesian coordinates for all atoms.\n\n    Returns\n    -------\n    None\n        The POSCAR file is written to ``file_name``.\n    \"\"\"\n    f = open(file_name, 'w')\n    f.write('written by python script\\n')\n    f.write('1.0\\n')\n\n    for i in range(3):\n        f.write('{0:20.12f}{1:20.12f}{2:20.12f}\\n'.format(box[i, 0], box[i, 1], box[i, 2]))\n\n    for i in range(len(a_type)):\n        f.write(' {}'.format(a_type[i]))\n    f.write('\\n')\n    for i in range(len(a_type)):\n        f.write(' {}'.format(num_type[i]))\n    f.write('\\n')\n\n    natom = np.sum(num_type)\n    f.write('C\\n')\n    for i in range(natom):\n        f.write('{0:20.12f}{1:20.12f}{2:20.12f}\\n'.format(coors[i, 0], coors[i, 1], coors[i, 2]))\n\n    f.close()\n</code></pre>"},{"location":"references/other/#m2dtools.other.common.write_xyz_file","title":"<code>write_xyz_file(atom_types, coordinates, filename, comment='')</code>","text":"<p>Write an XYZ file from atom types and coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>atom_types</code> <code>list[str]</code> <p>Atom types or symbols.</p> required <code>coordinates</code> <code>list[tuple[float, float, float]]</code> <p>Cartesian coordinates for each atom.</p> required <code>filename</code> <code>str</code> <p>Path to the output XYZ file.</p> required <code>comment</code> <code>str</code> <p>Comment to include on the second line of the file.</p> <code>\"\"</code> <p>Returns:</p> Type Description <code>None</code> <p>The XYZ file is written to <code>filename</code>.</p> Source code in <code>m2dtools/other/common.py</code> <pre><code>def write_xyz_file(atom_types, coordinates, filename, comment=\"\"):\n    \"\"\"Write an XYZ file from atom types and coordinates.\n\n    Parameters\n    ----------\n    atom_types : list[str]\n        Atom types or symbols.\n    coordinates : list[tuple[float, float, float]]\n        Cartesian coordinates for each atom.\n    filename : str\n        Path to the output XYZ file.\n    comment : str, default \"\"\n        Comment to include on the second line of the file.\n\n    Returns\n    -------\n    None\n        The XYZ file is written to ``filename``.\n    \"\"\"\n    num_atoms = len(atom_types)\n    with open(filename, 'w') as file:\n        file.write(f\"{num_atoms}\\n\")\n        file.write(f\"{comment}\\n\")\n        for atom_type, (x, y, z) in zip(atom_types, coordinates):\n            file.write(f\"{atom_type} {x:.6f} {y:.6f} {z:.6f}\\n\")\n</code></pre>"},{"location":"references/other/#m2dtools.other.tools_gro.gro2pos","title":"<code>gro2pos(posfile, grofile)</code>","text":"<p>Convert a <code>.gro</code> file to a POSCAR structure.</p> <p>Parameters:</p> Name Type Description Default <code>posfile</code> <code>str</code> <p>Destination POSCAR file path.</p> required <code>grofile</code> <code>str</code> <p>Source <code>.gro</code> trajectory file.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Writes the POSCAR representation to <code>posfile</code>.</p> Source code in <code>m2dtools/other/tools_gro.py</code> <pre><code>def gro2pos(posfile, grofile):\n    \"\"\"Convert a ``.gro`` file to a POSCAR structure.\n\n    Parameters\n    ----------\n    posfile : str\n        Destination POSCAR file path.\n    grofile : str\n        Source ``.gro`` trajectory file.\n\n    Returns\n    -------\n    None\n        Writes the POSCAR representation to ``posfile``.\n    \"\"\"\n    box, natom, type_atom, coors0 = read_gro('{}'.format(grofile))\n\n    elements = list(set(type_atom))\n    n_elements = len(elements)\n\n    n_atom = []\n    id_atom = []\n    for i_e in range(n_elements):\n        id_atom.append(np.array(np.where(type_atom == elements[i_e]))[0])\n        n_atom.append(id_atom[i_e].shape[0])\n\n    f1 = open('{}'.format(posfile), 'w')\n    f1.write('generated by gro2pos\\n')\n    f1.write(' 1.0\\n')\n    for ib in range(3):\n        f1.write(' {0:20.12f} {1:20.12f} {2:20.12f}\\n'.format(10*box[ib, 0], 10*box[ib, 1], 10*box[ib, 2]))\n\n    for i_e in range(n_elements):\n        f1.write(' {}'.format(elements[i_e]))\n    f1.write('\\n')\n\n    for i_e in range(n_elements):\n        f1.write(' {0:8d}'.format(n_atom[i_e]))\n    f1.write('\\n')\n    f1.write('C\\n')\n    for i_e in range(n_elements):\n        for ic in range(n_atom[i_e]):\n            f1.write(' {0:20.12f} {1:20.12f} {2:20.12f}\\n'.format(10*coors0[id_atom[i_e][ic], 0], 10*coors0[id_atom[i_e][ic], 1], 10*coors0[id_atom[i_e][ic], 2]))\n\n    f1.close()\n</code></pre>"},{"location":"references/other/#m2dtools.other.tools_gro.read_gro","title":"<code>read_gro(file_name)</code>","text":"<p>Read a GROMACS <code>.gro</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Path to the <code>.gro</code> file.</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, int, ndarray, ndarray]</code> <p>Box matrix, atom count, atom types and coordinates.</p> Source code in <code>m2dtools/other/tools_gro.py</code> <pre><code>def read_gro(file_name):\n    \"\"\"Read a GROMACS ``.gro`` file.\n\n    Parameters\n    ----------\n    file_name : str\n        Path to the ``.gro`` file.\n\n    Returns\n    -------\n    tuple[numpy.ndarray, int, numpy.ndarray, numpy.ndarray]\n        Box matrix, atom count, atom types and coordinates.\n    \"\"\"\n    f = open(file_name, 'r')\n    lf = list(f)\n    f.close()\n    len1 = float(lf[-1].split()[0])\n    len2 = float(lf[-1].split()[1])\n    len3 = float(lf[-1].split()[2])\n    box = np.diag([len1, len2, len3])\n    natom = int(lf[1])\n    coors = np.zeros([natom, 3])\n    type_atom = []\n    l = 0\n    for ia in lf[2:2+natom]:\n        if l &lt; 9999:\n            coors[l, :] = np.array(ia.split()[3:6:1]).astype('float')\n            type_atom.append(ia.split()[1])\n        else:\n            coors[l, :] = np.array(ia.split()[2:5:1]).astype('float')\n            tmp = ia.split()[1]\n            type_atom.append(re.findall(r'(\\w+?)(\\d+)', tmp)[0][0])\n        l += 1\n\n    type_atom = np.array(type_atom)\n    return box, natom, type_atom, coors\n</code></pre>"},{"location":"references/other/#m2dtools.other.tools_gro.read_gro_multi","title":"<code>read_gro_multi(gro_file)</code>","text":"<p>Read multiple frames from a concatenated <code>.gro</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>gro_file</code> <code>str</code> <p>Path to the multi-frame <code>.gro</code> file.</p> required <p>Returns:</p> Type Description <code>tuple[list, list]</code> <p>List of frame tuples <code>(box, natom, type_atom, coors)</code> and the corresponding timestep labels.</p> Source code in <code>m2dtools/other/tools_gro.py</code> <pre><code>def read_gro_multi(gro_file):\n    \"\"\"Read multiple frames from a concatenated ``.gro`` file.\n\n    Parameters\n    ----------\n    gro_file : str\n        Path to the multi-frame ``.gro`` file.\n\n    Returns\n    -------\n    tuple[list, list]\n        List of frame tuples ``(box, natom, type_atom, coors)`` and the\n        corresponding timestep labels.\n    \"\"\"\n\n    f = open(gro_file)\n    lft = list(f)\n    f.close()\n    lt = []\n    t = []\n    for il in range(len(lft)):\n        if 't=' in lft[il]:\n            lt.append(il)\n            t.append(lft[il].split()[2])\n\n    def read_lf(lf):\n        len1 = float(lf[-1].split()[0])\n        len2 = float(lf[-1].split()[1])\n        len3 = float(lf[-1].split()[2])\n        box = np.diag([len1, len2, len3])\n        natom = int(lf[1])\n        coors = np.zeros([natom, 3])\n        type_atom = []\n        l = 0\n        for ia in lf[2:2+natom]:\n            if l &lt; 9999:\n                coors[l, :] = np.array(ia.split()[3:6:1]).astype('float')\n                type_atom.append(ia.split()[1])\n            else:\n                coors[l, :] = np.array(ia.split()[2:5:1]).astype('float')\n                tmp = ia.split()[1]\n                type_atom.append(re.findall(r'(\\w+?)(\\d+)', tmp)[0][0])\n            l += 1\n\n        type_atom = np.array(type_atom)\n        return box, natom, type_atom, coors\n\n    # lf=[]\n    result = []\n    for it in range(len(lt)):\n        if it == len(lt)-1:\n            #         lf.append(lft[lt[it]:])\n            result.append(read_lf(lft[lt[it]:]))\n        else:\n            #         lf.append(lft[lt[it]:lt[it+1]-1])\n            result.append(read_lf(lft[lt[it]:lt[it+1]]))\n\n    return result, t\n</code></pre>"},{"location":"references/other/#m2dtools.other.tools_gro.write_gro","title":"<code>write_gro(filename, box, natom, type_atom, coors)</code>","text":"<p>Write a GROMACS <code>.gro</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Output file name without extension.</p> required <code>box</code> <code>ndarray</code> <p><code>(3, 3)</code> box matrix (orthogonal only).</p> required <code>natom</code> <code>int</code> <p>Number of atoms.</p> required <code>type_atom</code> <code>array - like</code> <p>Atom type identifiers.</p> required <code>coors</code> <code>ndarray</code> <p>Cartesian coordinates for each atom.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Writes <code>filename.gro</code> to disk.</p> Source code in <code>m2dtools/other/tools_gro.py</code> <pre><code>def write_gro(filename, box, natom, type_atom, coors):\n    \"\"\"Write a GROMACS ``.gro`` file.\n\n    Parameters\n    ----------\n    filename : str\n        Output file name without extension.\n    box : numpy.ndarray\n        ``(3, 3)`` box matrix (orthogonal only).\n    natom : int\n        Number of atoms.\n    type_atom : array-like\n        Atom type identifiers.\n    coors : numpy.ndarray\n        Cartesian coordinates for each atom.\n\n    Returns\n    -------\n    None\n        Writes ``filename.gro`` to disk.\n    \"\"\"\n    f = open('{}.gro'.format(filename), 'w')\n    f.write('SiO2\\n')\n    f.write('{0:5d} \\n'.format(natom))\n    for i in range(natom):\n        if i &lt; 9999:\n            f.write('{0:5d}SIO     {1:s}{2:5d}{3:8.3f}{4:8.3f}{5:8.3f}{6:8.4f}{7:8.4f}{8:8.4f}\\n'.format(i+1, type_atom[i], i+1, coors[i, 0], coors[i, 1], coors[i, 2], 0, 0, 0))\n        else:\n            f.write('{0:5d}SIO     {1:s}{2:6d}{3:8.3f}{4:8.3f}{5:8.3f}{6:8.4f}{7:8.4f}{8:8.4f}\\n'.format(i+1, type_atom[i], i+1, coors[i, 0], coors[i, 1], coors[i, 2], 0, 0, 0))\n    f.write('{0:10.5f}{1:10.5f}{2:10.5f}'.format(box[0, 0], box[1, 1], box[2, 2]))  # only work for othorgonal boxes\n    f.close()\n</code></pre>"},{"location":"references/basic/basic/","title":"Basic","text":"<p>Basic analysis utilities for molecular dynamics trajectories.</p> <p>This module gathers small helper routines for coordination numbers, angle distributions, compressibility, and force autocorrelations.</p>"},{"location":"references/basic/basic/#m2dtools.basic.basic.CN","title":"<code>CN(box, coors, cutoff)</code>","text":"<p>Compute coordination numbers within a cutoff.</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>ndarray</code> <p>Simulation cell vectors as a 3x3 matrix.</p> required <code>coors</code> <code>ndarray</code> <p>Atomic coordinates with shape <code>(n_atoms, 3)</code>.</p> required <code>cutoff</code> <code>float</code> <p>Distance cutoff for neighbor identification.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple <code>(CN, CN_idx, CN_dist, diff)</code> containing coordination counts, neighbor indices, neighbor distances, and displacement vectors under periodic boundary conditions.</p> Source code in <code>m2dtools/basic/basic.py</code> <pre><code>def CN(box, coors, cutoff):\n    \"\"\"Compute coordination numbers within a cutoff.\n\n    Parameters\n    ----------\n    box : np.ndarray\n        Simulation cell vectors as a 3x3 matrix.\n    coors : np.ndarray\n        Atomic coordinates with shape ``(n_atoms, 3)``.\n    cutoff : float\n        Distance cutoff for neighbor identification.\n\n    Returns\n    -------\n    tuple\n        A tuple ``(CN, CN_idx, CN_dist, diff)`` containing coordination\n        counts, neighbor indices, neighbor distances, and displacement\n        vectors under periodic boundary conditions.\n    \"\"\"\n\n    rcoors = np.dot(coors, np.linalg.inv(box))\n\n    r1 = rcoors[:, np.newaxis, :]\n    r2 = rcoors[np.newaxis, :, :]\n\n    rdis = r1-r2\n\n    while np.sum((rdis &lt; -0.5) | (rdis &gt; 0.5)) &gt; 0:\n        rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5]+1\n        rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5]-1\n\n    diff = np.dot(rdis, box)\n\n    dis = np.sqrt(np.sum(np.square(diff), axis=2))\n\n    CN_idx = []\n    CN_dist = []\n    CN = np.zeros(coors.shape[0])\n    for i in range(coors.shape[0]):\n        tmp = np.argwhere((dis[i, :] &lt; cutoff) &amp; (dis[i, :] &gt; 0))\n        CN[i] = tmp.shape[0]\n        CN_idx.append(tmp)\n        CN_dist.append(dis[i, (dis[i, :] &lt; cutoff) &amp; (dis[i, :] &gt; 0)])\n    return CN, CN_idx, CN_dist, diff\n</code></pre>"},{"location":"references/basic/basic/#m2dtools.basic.basic.CN_kdtree","title":"<code>CN_kdtree(box, coors, cutoff)</code>","text":"<p>Coordination number using KD-tree with orthorhombic PBC.</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>(3,3) ndarray</code> <p>Orthorhombic simulation cell (diagonal matrix).</p> required <code>coors</code> <code>(N,3) ndarray</code> <p>Atomic coordinates.</p> required <code>cutoff</code> <code>float</code> <p>Distance cutoff.</p> required <p>Returns:</p> Name Type Description <code>CN</code> <code>(N,) ndarray</code> <p>Coordination number (excluding self).</p> <code>CN_idx</code> <code>list of ndarray</code> <p>Neighbor indices for each atom.</p> <code>CN_dist</code> <code>list of ndarray</code> <p>Neighbor distances for each atom.</p> Source code in <code>m2dtools/basic/basic.py</code> <pre><code>def CN_kdtree(box, coors, cutoff):\n    \"\"\"\n    Coordination number using KD-tree with orthorhombic PBC.\n\n    Parameters\n    ----------\n    box : (3,3) ndarray\n        Orthorhombic simulation cell (diagonal matrix).\n    coors : (N,3) ndarray\n        Atomic coordinates.\n    cutoff : float\n        Distance cutoff.\n\n    Returns\n    -------\n    CN : (N,) ndarray\n        Coordination number (excluding self).\n    CN_idx : list of ndarray\n        Neighbor indices for each atom.\n    CN_dist : list of ndarray\n        Neighbor distances for each atom.\n    \"\"\"\n\n    box = np.asarray(box, dtype=float)\n    coors = np.asarray(coors, dtype=float)\n\n    # --- orthorhombic check ---\n    if not np.allclose(box, np.diag(np.diag(box))):\n        raise ValueError(\"CN_kdtree_ortho requires an orthorhombic box\")\n\n    box_lengths = np.diag(box)\n    N = coors.shape[0]\n\n    # --- KD-tree with periodicity ---\n    tree = cKDTree(coors, boxsize=box_lengths)\n\n    CN = np.zeros(N, dtype=int)\n    CN_idx = []\n    CN_dist = []\n\n    # --- neighbor search ---\n    for i in range(N):\n        js = tree.query_ball_point(coors[i], cutoff)\n\n        idx_i = []\n        dist_i = []\n\n        for j in js:\n            if j == i:\n                continue\n\n            # minimum-image displacement (orthorhombic)\n            d = coors[j] - coors[i]\n            d -= box_lengths * np.rint(d / box_lengths)\n\n            r = np.sqrt(d[0]**2 + d[1]**2 + d[2]**2)\n            if r &lt; cutoff:\n                idx_i.append(j)\n                dist_i.append(r)\n\n        CN[i] = len(idx_i)\n        CN_idx.append(np.asarray(idx_i, dtype=int))\n        CN_dist.append(np.asarray(dist_i, dtype=float))\n\n    return CN, CN_idx, CN_dist\n</code></pre>"},{"location":"references/basic/basic/#m2dtools.basic.basic.CN_large","title":"<code>CN_large(box, coors, cutoff)</code>","text":"<p>Compute coordination numbers for large systems.</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>ndarray</code> <p>Simulation cell vectors as a 3x3 matrix.</p> required <code>coors</code> <code>ndarray</code> <p>Atomic coordinates with shape <code>(n_atoms, 3)</code>.</p> required <code>cutoff</code> <code>float</code> <p>Distance cutoff for neighbor identification.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple <code>(CN, CN_idx, CN_dist)</code> with coordination counts, neighbor indices, and neighbor distances for each atom. Note that CN does include the atom itself.</p> Source code in <code>m2dtools/basic/basic.py</code> <pre><code>def CN_large(box, coors, cutoff):\n    \"\"\"Compute coordination numbers for large systems.\n\n    Parameters\n    ----------\n    box : np.ndarray\n        Simulation cell vectors as a 3x3 matrix.\n    coors : np.ndarray\n        Atomic coordinates with shape ``(n_atoms, 3)``.\n    cutoff : float\n        Distance cutoff for neighbor identification.\n\n    Returns\n    -------\n    tuple\n        A tuple ``(CN, CN_idx, CN_dist)`` with coordination counts,\n        neighbor indices, and neighbor distances for each atom.\n        Note that CN does include the atom itself.\n    \"\"\"\n    CN = []\n    CN_idx = []\n    CN_dist = []\n    for i in range(coors.shape[0]):\n        # find atom in the cubic at the center of coord[1], within the cutoff\n        coord0 = coors[i]\n        diff_coord = coors - coord0\n        # periodic boundary condition\n        diff_coord = diff_coord - np.round(diff_coord @ np.linalg.inv(box) ) @ box\n        idx_interest = np.argwhere((diff_coord[:, 0] &gt;= -cutoff)*(diff_coord[:, 0] &lt;= cutoff)*(diff_coord[:, 1] &gt;= -cutoff)*(diff_coord[:, 1] &lt;= cutoff)*(diff_coord[:, 2] &gt;= -cutoff)*(diff_coord[:, 2] &lt;= cutoff)).flatten()\n        dist_tmp = np.linalg.norm(diff_coord[idx_interest,:], axis=1)\n        idx_CN_tmp = np.argwhere(dist_tmp&lt;=cutoff).flatten()\n        CN.append(idx_CN_tmp.shape[0])\n        CN_idx.append(idx_interest[idx_CN_tmp])\n        CN_dist.append(dist_tmp[idx_CN_tmp])\n    return CN, CN_idx, CN_dist\n</code></pre>"},{"location":"references/basic/basic/#m2dtools.basic.basic.calc_compressibility","title":"<code>calc_compressibility(V, T=300)</code>","text":"<p>Calculate the isothermal compressibility from volume fluctuations.</p> <p>Parameters:</p> Name Type Description Default <code>V</code> <code>ndarray</code> <p>Array of volume samples in nm^3.</p> required <code>T</code> <code>float</code> <p>Temperature in Kelvin. Default is 300 K.</p> <code>300</code> <p>Returns:</p> Type Description <code>float</code> <p>Isothermal compressibility in <code>1/Pa</code>.</p> Source code in <code>m2dtools/basic/basic.py</code> <pre><code>def calc_compressibility(V, T=300):\n    \"\"\"Calculate the isothermal compressibility from volume fluctuations.\n\n    Parameters\n    ----------\n    V : np.ndarray\n        Array of volume samples in nm^3.\n    T : float, optional\n        Temperature in Kelvin. Default is 300 K.\n\n    Returns\n    -------\n    float\n        Isothermal compressibility in ``1/Pa``.\n    \"\"\"\n    kB = 1.380649e-23  # J/K\n    V = V * 1e-27  # Convert from nm^3 to m^3\n    kappa_T = np.var(V) / (V.mean() * kB * T)\n    return kappa_T * 1e9 # to 1/GPa\n</code></pre>"},{"location":"references/basic/basic/#m2dtools.basic.basic.compute_autocorrelation","title":"<code>compute_autocorrelation(forces, max_lag)</code>","text":"<p>Compute the force autocorrelation function (FAF).</p> <p>Parameters:</p> Name Type Description Default <code>forces</code> <code>ndarray</code> <p>Array of shape <code>(n_frames, n_atoms, 3)</code> containing forces per atom.</p> required <code>max_lag</code> <code>int</code> <p>Maximum lag time (in frames) for computing the autocorrelation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Force autocorrelation values with length <code>max_lag</code>.</p> Source code in <code>m2dtools/basic/basic.py</code> <pre><code>def compute_autocorrelation(forces, max_lag):\n    \"\"\"Compute the force autocorrelation function (FAF).\n\n    Parameters\n    ----------\n    forces : np.ndarray\n        Array of shape ``(n_frames, n_atoms, 3)`` containing forces per\n        atom.\n    max_lag : int\n        Maximum lag time (in frames) for computing the autocorrelation.\n\n    Returns\n    -------\n    np.ndarray\n        Force autocorrelation values with length ``max_lag``.\n    \"\"\"\n    n_frames, n_atoms, _ = forces.shape\n\n    # Initialize autocorrelation array\n    faf = np.zeros(max_lag)\n\n    # Loop over lag times\n    for lag in range(max_lag):\n        # Compute dot product of forces separated by lag\n        dot_products = np.sum(forces[:n_frames - lag] * forces[lag:], axis=(1, 2))\n        faf[lag] = np.mean(dot_products)\n\n    # Normalize by the zero-lag correlation\n    faf /= faf[0]\n\n    return faf\n</code></pre>"},{"location":"references/basic/dynamics/","title":"Dynamics","text":"<p>Dynamic analysis routines for trajectory data.</p>"},{"location":"references/basic/dynamics/#m2dtools.basic.dynamics.compute_D","title":"<code>compute_D(time, msd, fit_from=0, dim=3)</code>","text":"<p>Compute the diffusion coefficient from an MSD curve.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>ndarray</code> <p>Time values corresponding to the MSD entries.</p> required <code>msd</code> <code>ndarray</code> <p>Mean-squared displacement values.</p> required <code>fit_from</code> <code>int</code> <p>Index at which to start the linear regression. Default is <code>0</code>.</p> <code>0</code> <code>dim</code> <code>int</code> <p>Dimensionality of the system (e.g., <code>3</code> for 3D). Default is <code>3</code>.</p> <code>3</code> <p>Returns:</p> Type Description <code>float</code> <p>Estimated diffusion coefficient in units of <code>msd/time</code>.</p> Source code in <code>m2dtools/basic/dynamics.py</code> <pre><code>def compute_D(time, msd, fit_from=0, dim=3):\n    \"\"\"Compute the diffusion coefficient from an MSD curve.\n\n    Parameters\n    ----------\n    time : np.ndarray\n        Time values corresponding to the MSD entries.\n    msd : np.ndarray\n        Mean-squared displacement values.\n    fit_from : int, optional\n        Index at which to start the linear regression. Default is ``0``.\n    dim : int, optional\n        Dimensionality of the system (e.g., ``3`` for 3D). Default is ``3``.\n\n    Returns\n    -------\n    float\n        Estimated diffusion coefficient in units of ``msd/time``.\n    \"\"\"\n    coeffs = np.polyfit(time[fit_from:], msd[fit_from:], 1)\n    D = coeffs[0] / 2 / dim # in unit of msd / time\n    return D\n</code></pre>"},{"location":"references/basic/dynamics/#m2dtools.basic.dynamics.compute_SISF","title":"<code>compute_SISF(positions, box_lengths, lag_array, k, num_vectors=100, n_repeat=100)</code>","text":"<p>Compute the self-intermediate scattering function (SISF).</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>ndarray</code> <p>Atom positions with shape <code>(n_frames, n_atoms, 3)</code>.</p> required <code>box_lengths</code> <code>ndarray or list</code> <p>Simulation box lengths per frame with shape <code>(n_frames, 3)</code>.</p> required <code>lag_array</code> <code>ndarray or list</code> <p>Lag times (in frames) at which to evaluate the SISF.</p> required <code>k</code> <code>float</code> <p>Magnitude of the wave vector <code>|k|</code>.</p> required <code>num_vectors</code> <code>int</code> <p>Number of random <code>k</code>-vectors to sample. Default is <code>100</code>.</p> <code>100</code> <code>n_repeat</code> <code>int</code> <p>Number of time origins to average over. Default is <code>100</code>.</p> <code>100</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Self-intermediate scattering values for each lag time.</p> Source code in <code>m2dtools/basic/dynamics.py</code> <pre><code>def compute_SISF(positions, box_lengths, lag_array, k, num_vectors=100, n_repeat=100):\n    \"\"\"Compute the self-intermediate scattering function (SISF).\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        Atom positions with shape ``(n_frames, n_atoms, 3)``.\n    box_lengths : np.ndarray or list\n        Simulation box lengths per frame with shape ``(n_frames, 3)``.\n    lag_array : np.ndarray or list\n        Lag times (in frames) at which to evaluate the SISF.\n    k : float\n        Magnitude of the wave vector ``|k|``.\n    num_vectors : int, optional\n        Number of random ``k``-vectors to sample. Default is ``100``.\n    n_repeat : int, optional\n        Number of time origins to average over. Default is ``100``.\n\n    Returns\n    -------\n    np.ndarray\n        Self-intermediate scattering values for each lag time.\n    \"\"\"\n    n_frames, n_atoms, _ = positions.shape\n\n    # Unwrap positions considering periodic boundary conditions\n    unwrapped_pos = np.zeros_like(positions)\n    unwrapped_pos[0] = positions[0]\n\n    for t in range(1, n_frames):\n        box_length_tmp = (box_lengths[t] + box_lengths[t - 1]) / 2\n        delta = positions[t] - unwrapped_pos[t - 1]\n        delta -= box_length_tmp * np.round(delta / box_length_tmp)\n        unwrapped_pos[t] = unwrapped_pos[t - 1] + delta\n\n    sisf = np.zeros(len(lag_array))\n    vectors=random_vectors(k, num_vectors)\n\n    for i, lag in enumerate(lag_array):\n        if len(positions)-lag &lt; n_repeat:\n            displacements = unwrapped_pos[lag:] - unwrapped_pos[:-lag]\n            #compute cos(k*r) for each random vector and average\n            cos_kr = np.cos(np.einsum('ij,tkj-&gt;tki', vectors, displacements))\n        else:\n            random_indices = np.random.choice(len(positions)-lag, n_repeat)\n            displacements = unwrapped_pos[lag + random_indices] - unwrapped_pos[random_indices]\n            cos_kr = np.cos(np.einsum('ij,tkj-&gt;tki', vectors, displacements))\n        sisf[i] = np.mean(cos_kr)\n    return sisf\n</code></pre>"},{"location":"references/basic/dynamics/#m2dtools.basic.dynamics.compute_SISF_zresolved","title":"<code>compute_SISF_zresolved(positions, box_lengths, lag_array, k, z_ranges, num_vectors=100, n_repeat=100)</code>","text":"<p>Layer-resolved SISF with z-bin assignment performed at every time origin t0.</p> <p>Parameters:</p> Name Type Description Default <code>z_ranges</code> <code>list of tuple</code> <p>List of (zmin, zmax) tuples defining the layers along z-axis.</p> required <code>Other</code> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Self-intermediate scattering values for each layer and lag time.</p> Source code in <code>m2dtools/basic/dynamics.py</code> <pre><code>def compute_SISF_zresolved(positions, box_lengths, lag_array, k,\n                            z_ranges,\n                            num_vectors=100, n_repeat=100) -&gt; np.ndarray:\n    \"\"\"\n    Layer-resolved SISF with z-bin assignment performed at every time origin t0.\n\n    Parameters\n    ----------\n    z_ranges : list of tuple\n        List of (zmin, zmax) tuples defining the layers along z-axis.\n    Other parameters are the same as in `compute_SISF`.\n\n    Returns\n    -------\n    np.ndarray\n        Self-intermediate scattering values for each layer and lag time.\n    \"\"\"\n\n    n_frames, n_atoms, _ = positions.shape\n    n_layers = len(z_ranges)\n\n    # ---- unwrap ----\n    unwrapped = np.zeros_like(positions)\n    unwrapped[0] = positions[0]\n\n    for t in range(1, n_frames):\n        box_tmp = 0.5 * (box_lengths[t] + box_lengths[t-1])\n        delta = positions[t] - unwrapped[t-1]\n        delta -= box_tmp * np.round(delta / box_tmp)\n        unwrapped[t] = unwrapped[t-1] + delta\n\n    # ---- random k vectors ----\n    vectors = random_vectors_2D(k, num_vectors)\n\n    # ---- output ----\n    sisf_layers = np.zeros((n_layers, len(lag_array)))\n\n    # ---- compute for each lag ----\n    for i, lag in enumerate(lag_array):\n\n        max_origin = n_frames - lag\n        if max_origin &lt; n_repeat:\n            origins = np.arange(max_origin)\n        else:\n            origins = np.random.choice(max_origin, n_repeat, replace=False)\n\n        # accumulator for each layer\n        accum = [ [] for _ in range(n_layers) ]\n\n        for t0 in origins:\n            z_now = unwrapped[t0, :, 2]   # z positions at time origin\n\n            # assign atoms at this time origin\n            atom_layers = []\n            for (zmin, zmax) in z_ranges:\n                atom_layers.append(np.where((z_now &gt;= zmin) &amp; (z_now &lt; zmax))[0])\n\n            # compute displacements from t0 to t0+lag\n            disp = unwrapped[t0 + lag] - unwrapped[t0]   # (N,3)\n\n            for L, atoms_L in enumerate(atom_layers):\n                if len(atoms_L) == 0:\n                    continue\n\n                d = disp[atoms_L]           # (n_atoms_L, 3)\n\n                cos_kr = np.cos(np.einsum(\"ij,nj-&gt;ni\", vectors, d))\n                accum[L].append(np.mean(cos_kr))\n\n        # average for each layer\n        for L in range(n_layers):\n            if len(accum[L]) &gt; 0:\n                sisf_layers[L, i] = np.mean(accum[L])\n\n    return sisf_layers\n</code></pre>"},{"location":"references/basic/dynamics/#m2dtools.basic.dynamics.compute_msd_pbc","title":"<code>compute_msd_pbc(positions, box_lengths, lag_array)</code>","text":"<p>Compute mean-squared displacement with periodic boundaries.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>ndarray</code> <p>Atom positions with shape <code>(n_frames, n_atoms, 3)</code>.</p> required <code>box_lengths</code> <code>ndarray or list</code> <p>Simulation box lengths per frame with shape <code>(n_frames, 3)</code>.</p> required <code>lag_array</code> <code>ndarray or list</code> <p>Lag times (in frames) at which to evaluate the MSD.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Mean-squared displacement values for each lag time.</p> Source code in <code>m2dtools/basic/dynamics.py</code> <pre><code>def compute_msd_pbc(positions, box_lengths, lag_array):\n    \"\"\"Compute mean-squared displacement with periodic boundaries.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        Atom positions with shape ``(n_frames, n_atoms, 3)``.\n    box_lengths : np.ndarray or list\n        Simulation box lengths per frame with shape ``(n_frames, 3)``.\n    lag_array : np.ndarray or list\n        Lag times (in frames) at which to evaluate the MSD.\n\n    Returns\n    -------\n    np.ndarray\n        Mean-squared displacement values for each lag time.\n    \"\"\"\n    n_frames, n_atoms, _ = positions.shape\n\n    # Unwrap positions considering periodic boundary conditions\n    unwrapped_pos = np.zeros_like(positions)\n    unwrapped_pos[0] = positions[0]\n\n    for t in range(1, n_frames):\n        box_length_tmp = (box_lengths[t] + box_lengths[t - 1]) / 2\n        delta = positions[t] - unwrapped_pos[t - 1]\n        delta -= box_length_tmp * np.round(delta / box_length_tmp)\n        unwrapped_pos[t] = unwrapped_pos[t - 1] + delta\n\n    msd = np.zeros(len(lag_array))\n\n    for i, lag in enumerate(lag_array):\n        displacements = unwrapped_pos[lag:] - unwrapped_pos[:-lag]\n        squared_displacements = np.sum(displacements**2, axis=2)\n        msd[i] = np.mean(squared_displacements)\n\n    return msd\n</code></pre>"},{"location":"references/basic/structure/","title":"Structure","text":"<p>Structural analysis helpers for molecular simulations.</p> <p>The functions in this module compute bond lengths, angles, pair distribution functions (PDF), and structure factors (SQ) for one or multiple particle species.</p>"},{"location":"references/basic/structure/#m2dtools.basic.structure.angle_distribution","title":"<code>angle_distribution(coors, box, cutoff)</code>","text":"<p>Compute the O\u2013O\u2013O angle distribution within a cutoff.</p> <p>Parameters:</p> Name Type Description Default <code>coors</code> <code>ndarray</code> <p>Atomic coordinates with shape <code>(n_atoms, 3)</code>.</p> required <code>box</code> <code>ndarray</code> <p>Simulation cell vectors as a 3x3 matrix.</p> required <code>cutoff</code> <code>float</code> <p>Maximum O\u2013O separation to include in the triplet selection.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Angles in degrees for all qualifying triplets.</p> Source code in <code>m2dtools/basic/structure.py</code> <pre><code>def angle_distribution(coors, box, cutoff):\n    \"\"\"Compute the O\u2013O\u2013O angle distribution within a cutoff.\n\n    Parameters\n    ----------\n    coors : np.ndarray\n        Atomic coordinates with shape ``(n_atoms, 3)``.\n    box : np.ndarray\n        Simulation cell vectors as a 3x3 matrix.\n    cutoff : float\n        Maximum O\u2013O separation to include in the triplet selection.\n\n    Returns\n    -------\n    list[float]\n        Angles in degrees for all qualifying triplets.\n    \"\"\"\n    n_atom = coors.shape[0]\n    angles = []\n    rcoors = np.dot(coors, np.linalg.inv(box))\n    rdis = np.zeros([n_atom, n_atom, 3])\n    for i in range(n_atom):\n        tmp = rcoors[i]\n        rdis[i, :, :] = tmp - rcoors\n    rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5] + 1\n    rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5] - 1\n    a = np.dot(rdis[:, :, :], box)\n    dis = np.sqrt((np.square(a[:, :, 0]) + np.square(a[:, :, 1]) + np.square(a[:, :, 2])))\n\n    for i in range(n_atom):\n        for j in np.arange(i+1, n_atom):\n            for k in np.arange(j+1, n_atom):\n                if dis[i, j] &lt; cutoff and dis[i, k] &lt; cutoff and dis[j, k] &lt; cutoff:\n                    angle = calculate_angle(a[j, i, :], a[k, i, :])\n                    angles.append(angle)\n                    angle = calculate_angle(a[i, j, :], a[k, j, :])\n                    angles.append(angle)\n                    angle = calculate_angle(a[i, k, :], a[j, k, :])\n                    angles.append(angle)\n    return angles\n</code></pre>"},{"location":"references/basic/structure/#m2dtools.basic.structure.calculate_angle","title":"<code>calculate_angle(v1, v2)</code>","text":"<p>Calculate the angle between two vectors.</p> <p>Parameters:</p> Name Type Description Default <code>v1</code> <code>ndarray</code> <p>First vector.</p> required <code>v2</code> <code>ndarray</code> <p>Second vector.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Angle in degrees between <code>v1</code> and <code>v2</code>.</p> Source code in <code>m2dtools/basic/structure.py</code> <pre><code>def calculate_angle(v1, v2):\n    \"\"\"Calculate the angle between two vectors.\n\n    Parameters\n    ----------\n    v1 : np.ndarray\n        First vector.\n    v2 : np.ndarray\n        Second vector.\n\n    Returns\n    -------\n    float\n        Angle in degrees between ``v1`` and ``v2``.\n    \"\"\"\n    cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))\n    # convert to angle degree\n    angle = np.arccos(cos_angle)/np.pi*180\n    return angle\n</code></pre>"},{"location":"references/basic/structure/#m2dtools.basic.structure.pdf_sq_1type","title":"<code>pdf_sq_1type(box_size, natom, coors, r_cutoff=10, delta_r=0.01)</code>","text":"<p>Calculate PDF and SQ for a single particle type.</p> <p>Parameters:</p> Name Type Description Default <code>box_size</code> <code>float</code> <p>Length of the cubic simulation box (\u00c5).</p> required <code>natom</code> <code>int</code> <p>Number of atoms of the single particle type.</p> required <code>coors</code> <code>ndarray</code> <p>Atomic coordinates with shape <code>(n_atoms, 3)</code>.</p> required <code>r_cutoff</code> <code>float</code> <p>Maximum pair distance to consider. Default is <code>10</code>.</p> <code>10</code> <code>delta_r</code> <code>float</code> <p>Bin width for the radial histogram. Default is <code>0.01</code>.</p> <code>0.01</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple <code>(R, g1, Q, S1)</code> where <code>R</code> are radial bin centers, <code>g1</code> is the pair distribution, <code>Q</code> is the scattering vector, and <code>S1</code> is the structure factor.</p> Source code in <code>m2dtools/basic/structure.py</code> <pre><code>def pdf_sq_1type(box_size, natom, coors, r_cutoff=10, delta_r=0.01):\n    \"\"\"Calculate PDF and SQ for a single particle type.\n\n    Parameters\n    ----------\n    box_size : float\n        Length of the cubic simulation box (\u00c5).\n    natom : int\n        Number of atoms of the single particle type.\n    coors : np.ndarray\n        Atomic coordinates with shape ``(n_atoms, 3)``.\n    r_cutoff : float, optional\n        Maximum pair distance to consider. Default is ``10``.\n    delta_r : float, optional\n        Bin width for the radial histogram. Default is ``0.01``.\n\n    Returns\n    -------\n    tuple\n        Tuple ``(R, g1, Q, S1)`` where ``R`` are radial bin centers,\n        ``g1`` is the pair distribution, ``Q`` is the scattering vector,\n        and ``S1`` is the structure factor.\n    \"\"\"\n    box = np.array([[box_size, 0, 0],\n                    [0, box_size, 0],\n                    [0, 0, box_size]])\n    n1 = natom\n    rcoors = np.dot(coors, np.linalg.inv(box))\n    rdis = np.zeros([natom, natom, 3])\n    for i in range(natom):\n        tmp = rcoors[i]\n        rdis[i, :, :] = tmp - rcoors\n    rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5] + 1\n    rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5] - 1\n    a = np.dot(rdis[:, :, :], box)\n    dis = np.sqrt((np.square(a[:, :, 0]) + np.square(a[:, :, 1]) + np.square(a[:, :, 2])))\n    r_max = r_cutoff\n    r = np.linspace(delta_r, r_max, int(r_max / delta_r))\n    V = np.dot(np.cross(box[1, :], box[2, :]), box[0, :])\n    rho1 = n1 / V\n    c = np.array([rho1 * rho1]) * V\n    g1 = np.histogram(dis[:n1, :n1], bins=r)[0] / (4 * np.pi *\n                                                   (r[1:] - delta_r / 2) ** 2 * delta_r * c[0])\n    R = r[1:] - delta_r / 2\n\n    dq = 0.01\n    qrange = [np.pi / 2 / r_max, 25]\n    Q = np.arange(np.floor(qrange[0] / dq), np.floor(qrange[1] / dq), 1) * dq\n    S1 = np.zeros([len(Q)])\n    rho = natom / np.dot(np.cross(box[1, :], box[2, :]), box[0, :]) #/ 10 ** 3\n    # use a window function for fourier transform\n    for i in np.arange(len(Q)):\n        S1[i] = 1 + 4 * np.pi * rho / Q[i] * np.trapz(\n            (g1 - 1) * np.sin(Q[i] * R) * R * np.sin(np.pi * R / r_max) / (np.pi * R / r_max), R)\n\n    return R, g1, Q, S1\n</code></pre>"},{"location":"references/basic/structure/#m2dtools.basic.structure.pdf_sq_cross_mask","title":"<code>pdf_sq_cross_mask(box, coors1, coors2, mask_matrix, r_cutoff=10, delta_r=0.01)</code>","text":"<p>Calculate PDF and SQ between two particle sets with masking.</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>ndarray</code> <p>Simulation cell vectors as a 3x3 matrix.</p> required <code>coors1</code> <code>ndarray</code> <p>Coordinates of the first particle set with shape <code>(n1, 3)</code>.</p> required <code>coors2</code> <code>ndarray</code> <p>Coordinates of the second particle set with shape <code>(n2, 3)</code>.</p> required <code>mask_matrix</code> <code>ndarray</code> <p>Matrix masking pair contributions; masked entries are ignored.</p> required <code>r_cutoff</code> <code>float</code> <p>Maximum pair distance to consider. Default is <code>10</code>.</p> <code>10</code> <code>delta_r</code> <code>float</code> <p>Bin width for the radial histogram. Default is <code>0.01</code>.</p> <code>0.01</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple <code>(R, g1, Q, S1)</code> where <code>R</code> are radial bin centers, <code>g1</code> is the pair distribution, <code>Q</code> is the scattering vector, and <code>S1</code> is the structure factor.</p> Source code in <code>m2dtools/basic/structure.py</code> <pre><code>def pdf_sq_cross_mask(box, coors1, coors2,  mask_matrix, r_cutoff:float=10, delta_r:float=0.01):\n    \"\"\"Calculate PDF and SQ between two particle sets with masking.\n\n    Parameters\n    ----------\n    box : np.ndarray\n        Simulation cell vectors as a 3x3 matrix.\n    coors1 : np.ndarray\n        Coordinates of the first particle set with shape ``(n1, 3)``.\n    coors2 : np.ndarray\n        Coordinates of the second particle set with shape ``(n2, 3)``.\n    mask_matrix : np.ndarray\n        Matrix masking pair contributions; masked entries are ignored.\n    r_cutoff : float, optional\n        Maximum pair distance to consider. Default is ``10``.\n    delta_r : float, optional\n        Bin width for the radial histogram. Default is ``0.01``.\n\n    Returns\n    -------\n    tuple\n        Tuple ``(R, g1, Q, S1)`` where ``R`` are radial bin centers,\n        ``g1`` is the pair distribution, ``Q`` is the scattering vector,\n        and ``S1`` is the structure factor.\n    \"\"\"\n    n1 = len(coors1)\n    n2 = len(coors2)\n    natom = n1 + n2\n    rcoors1 = np.dot(coors1, np.linalg.inv(box))\n    rcoors2 = np.dot(coors2, np.linalg.inv(box))\n    rdis = np.zeros([n1, n2, 3])\n    for i in range(n1):\n        tmp = rcoors1[i]\n        rdis[i, :, :] = tmp - rcoors2\n    rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5] + 1\n    rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5] - 1\n    a = np.dot(rdis[:, :, :], box)\n    dis = np.sqrt((np.square(a[:, :, 0]) + np.square(a[:, :, 1]) + np.square(a[:, :, 2])))\n\n    dis = dis * mask_matrix\n\n    r_max = r_cutoff\n    r = np.linspace(delta_r, r_max, int(r_max / delta_r))\n    V = np.dot(np.cross(box[1, :], box[2, :]), box[0, :])\n    rho1 = n1/V\n    rho2 = n2/V\n    c = np.array([rho1 * rho2]) * V\n    g1 = np.histogram(dis, bins=r)[0] / (4 * np.pi * (r[1:] - delta_r / 2) ** 2 * delta_r * c[0])\n    R = r[1:] - delta_r / 2\n\n    dq = 0.01\n    qrange = [np.pi / 2 / r_max, 25]\n    Q = np.arange(np.floor(qrange[0] / dq), np.floor(qrange[1] / dq), 1) * dq\n    S1 = np.zeros([len(Q)])\n    rho = natom / np.dot(np.cross(box[1, :], box[2, :]), box[0, :]) #/ 10 ** 3\n    # use a window function for fourier transform\n    for i in np.arange(len(Q)):\n        S1[i] = 1 + 4 * np.pi * rho / Q[i] * np.trapz(\n            (g1 - 1) * np.sin(Q[i] * R) * R * np.sin(np.pi * R / r_max) / (np.pi * R / r_max), R)\n\n    return R, g1, Q, S1\n</code></pre>"},{"location":"references/basic/structure/#m2dtools.basic.structure.pdf_sq_cross_mask_large","title":"<code>pdf_sq_cross_mask_large(box, coors1, coors2, mask_matrix, r_cutoff=10.0, delta_r=0.01)</code>","text":"<p>Compute the masked cross radial distribution function (pair distribution function) g(r) between two coordinate sets using a periodic KD-tree neighbor search, optimized for large systems.</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>(array_like, shape(3, 3))</code> <p>Simulation cell vectors. Assumed orthorhombic in practice; periodic wrapping is applied using the per-axis box lengths derived from the row norms.</p> required <code>coors1</code> <code>(array_like, shape(n1, 3))</code> <p>Cartesian coordinates of species/set 1.</p> required <code>coors2</code> <code>(array_like, shape(n2, 3))</code> <p>Cartesian coordinates of species/set 2 (used to build the KD-tree).</p> required <code>mask_matrix</code> <code>(array_like, shape(n1, n2))</code> <p>Boolean (or 0/1) mask selecting which (i, j) pairs are included in the RDF. Only distances for which <code>mask_matrix[i, j]</code> is truthy contribute to the histogram.</p> required <code>r_cutoff</code> <code>float</code> <p>Cutoff radius (in the same units as coordinates) for neighbor search and RDF.</p> <code>10.0</code> <code>delta_r</code> <code>float</code> <p>Bin width for the radial histogram.</p> <code>0.01</code> <p>Returns:</p> Name Type Description <code>r_centers</code> <code>ndarray</code> <p>Radii at the centers of the histogram bins.</p> <code>g_r</code> <code>ndarray</code> <p>Estimated cross RDF g(r) for the masked pairs.</p> <code>Q</code> <code>ndarray</code> <p>Scattering vector magnitudes for the computed structure factor S(Q).</p> <code>S1</code> <code>ndarray</code> <p>Structure factor S(Q) computed from g(r).</p> Source code in <code>m2dtools/basic/structure.py</code> <pre><code>def pdf_sq_cross_mask_large(\n    box,\n    coors1,\n    coors2,\n    mask_matrix,\n    r_cutoff: float = 10.0,\n    delta_r: float = 0.01,\n):\n    \"\"\"\n    Compute the masked cross radial distribution function (pair distribution function) g(r)\n    between two coordinate sets using a periodic KD-tree neighbor search, optimized for large systems.\n\n    Parameters\n    ----------\n    box : array_like, shape (3, 3)\n        Simulation cell vectors. Assumed orthorhombic in practice; periodic wrapping is\n        applied using the per-axis box lengths derived from the row norms.\n\n    coors1 : array_like, shape (n1, 3)\n        Cartesian coordinates of species/set 1.\n\n    coors2 : array_like, shape (n2, 3)\n        Cartesian coordinates of species/set 2 (used to build the KD-tree).\n\n    mask_matrix : array_like, shape (n1, n2)\n        Boolean (or 0/1) mask selecting which (i, j) pairs are included in the RDF.\n        Only distances for which `mask_matrix[i, j]` is truthy contribute to the histogram.\n\n    r_cutoff : float, default=10.0\n        Cutoff radius (in the same units as coordinates) for neighbor search and RDF.\n\n    delta_r : float, default=0.01\n        Bin width for the radial histogram.\n\n    Returns\n    -------\n    r_centers : numpy.ndarray\n        Radii at the centers of the histogram bins.\n    g_r : numpy.ndarray\n        Estimated cross RDF g(r) for the masked pairs.\n    Q : numpy.ndarray\n        Scattering vector magnitudes for the computed structure factor S(Q).\n    S1 : numpy.ndarray\n        Structure factor S(Q) computed from g(r).\n    \"\"\"\n\n    t0 = time.time()\n    n1, n2 = len(coors1), len(coors2)\n\n    # box lengths (orthorhombic)\n    box_lengths = np.linalg.norm(box, axis=1)\n\n    # build tree\n    tree = cKDTree(\n        coors2,\n        boxsize=box_lengths \n    )\n\n    # neighbor search\n    pairs = tree.query_ball_point(coors1, r_cutoff)\n\n    # collect distances\n    distances = []\n    for i, js in enumerate(pairs):\n        if not js:\n            continue\n        for j in js:\n            if mask_matrix[i, j]:\n                d = coors1[i] - coors2[j]\n                d -= box_lengths * np.rint(d / box_lengths)\n                distances.append(np.linalg.norm(d))\n\n    distances = np.asarray(distances)\n\n    # --- PDF ---\n    r_edges = np.arange(delta_r, r_cutoff + delta_r, delta_r)\n    r_centers = 0.5 * (r_edges[1:] + r_edges[:-1])\n\n    V = np.dot(np.cross(box[1], box[2]), box[0])\n    rho1, rho2 = n1 / V, n2 / V\n    norm = rho1 * rho2 * V\n    hist, _ = np.histogram(distances, bins=r_edges)\n    g1 = hist / (4 * np.pi * r_centers**2 * delta_r * norm)\n\n    dq = 0.01\n    qrange = [np.pi / 2 / r_cutoff, 25]\n    Q = np.arange(np.floor(qrange[0] / dq), np.floor(qrange[1] / dq), 1) * dq\n    S1 = np.zeros([len(Q)])\n    natom = n1 + n2\n    rho = natom / np.dot(np.cross(box[1, :], box[2, :]), box[0, :]) #/ 10 ** 3\n    # use a window function for fourier transform\n    R = r_centers\n    r_max = r_cutoff\n    for i in np.arange(len(Q)):\n        S1[i] = 1 + 4 * np.pi * rho / Q[i] * np.trapz(\n            (g1 - 1) * np.sin(Q[i] * R) * R * np.sin(np.pi * R / r_max) / (np.pi * R / r_max), R)\n\n    print(f\"KD-tree PDF time: {time.time() - t0:.2f} s\")\n    return r_centers, g1, Q, S1\n</code></pre>"}]}