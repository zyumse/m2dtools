{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to m2dtools Documentation","text":"<p>m2dtools is a lightweight Python toolkit for molecular simulation workflows, providing utilities for structure handling, trajectory analysis, coarse-graining, and LAMMPS interfacing. It is designed to support multiscale molecular modeling with simple, modular components that can be used independently or combined into automated pipelines.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Structure and trajectory utilities   Read, write, filter, and manipulate molecular data with minimal overhead.</p> </li> <li> <p>Coarse-graining support   Tools for computing RDFs, bonded distributions, and preparing inputs for CG   force-field optimization workflows.</p> </li> <li> <p>LAMMPS helpers   Read full-style data files, extract atom and topology information, and prepare   simulation inputs.</p> </li> <li> <p>Network and graph tools   Construct connectivity networks, compute graph-based descriptors, and analyze   polymer or molecular connectivity.</p> </li> <li> <p>Modular design   Each submodule is self-contained, making it easy to integrate with existing   workflows in MD, CGMD, or ML-accelerated simulations.</p> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install m2dtools\n</code></pre> <p>Or install from source:</p> <pre><code>git clone https://github.com/zyumse/m2dtools\ncd m2dtools\npip install -e .\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Load and inspect a LAMMPS full-style data file:</p> <pre><code>from m2dtools.lmp import read_lammps_full\n\nlmp = read_lammps_full(\"system.data\")\nprint(lmp.atom_info.shape)\nprint(lmp.bonds[:10])\n</code></pre> <p>Compute an RDF from coordinates:</p> <pre><code>from m2dtools.cg import compute_rdf\nrdf, r = compute_rdf(positions, box, dr=0.01, rmax=20.0)\n</code></pre>"},{"location":"references/basic/","title":"Basic module","text":""},{"location":"references/basic/#structure","title":"Structure","text":"<p>Structural analysis helpers for molecular simulations.</p> <p>The functions in this module compute bond lengths, angles, pair distribution functions (PDF), and structure factors (SQ) for one or multiple particle species.</p>"},{"location":"references/basic/#m2dtools.basic.structure.angle_distribution","title":"<code>angle_distribution(coors, box, cutoff)</code>","text":"<p>Compute the O\u2013O\u2013O angle distribution within a cutoff.</p>"},{"location":"references/basic/#m2dtools.basic.structure.angle_distribution--parameters","title":"Parameters","text":"<p>coors : np.ndarray     Atomic coordinates with shape <code>(n_atoms, 3)</code>. box : np.ndarray     Simulation cell vectors as a 3x3 matrix. cutoff : float     Maximum O\u2013O separation to include in the triplet selection.</p>"},{"location":"references/basic/#m2dtools.basic.structure.angle_distribution--returns","title":"Returns","text":"<p>list[float]     Angles in degrees for all qualifying triplets.</p> Source code in <code>m2dtools/basic/structure.py</code> <pre><code>def angle_distribution(coors, box, cutoff):\n    \"\"\"Compute the O\u2013O\u2013O angle distribution within a cutoff.\n\n    Parameters\n    ----------\n    coors : np.ndarray\n        Atomic coordinates with shape ``(n_atoms, 3)``.\n    box : np.ndarray\n        Simulation cell vectors as a 3x3 matrix.\n    cutoff : float\n        Maximum O\u2013O separation to include in the triplet selection.\n\n    Returns\n    -------\n    list[float]\n        Angles in degrees for all qualifying triplets.\n    \"\"\"\n    n_atom = coors.shape[0]\n    angles = []\n    rcoors = np.dot(coors, np.linalg.inv(box))\n    rdis = np.zeros([n_atom, n_atom, 3])\n    for i in range(n_atom):\n        tmp = rcoors[i]\n        rdis[i, :, :] = tmp - rcoors\n    rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5] + 1\n    rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5] - 1\n    a = np.dot(rdis[:, :, :], box)\n    dis = np.sqrt((np.square(a[:, :, 0]) + np.square(a[:, :, 1]) + np.square(a[:, :, 2])))\n\n    for i in range(n_atom):\n        for j in np.arange(i+1, n_atom):\n            for k in np.arange(j+1, n_atom):\n                if dis[i, j] &lt; cutoff and dis[i, k] &lt; cutoff and dis[j, k] &lt; cutoff:\n                    angle = calculate_angle(a[j, i, :], a[k, i, :])\n                    angles.append(angle)\n                    angle = calculate_angle(a[i, j, :], a[k, j, :])\n                    angles.append(angle)\n                    angle = calculate_angle(a[i, k, :], a[j, k, :])\n                    angles.append(angle)\n    return angles\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.structure.calculate_angle","title":"<code>calculate_angle(v1, v2)</code>","text":"<p>Calculate the angle between two vectors.</p>"},{"location":"references/basic/#m2dtools.basic.structure.calculate_angle--parameters","title":"Parameters","text":"<p>v1 : np.ndarray     First vector. v2 : np.ndarray     Second vector.</p>"},{"location":"references/basic/#m2dtools.basic.structure.calculate_angle--returns","title":"Returns","text":"<p>float     Angle in degrees between <code>v1</code> and <code>v2</code>.</p> Source code in <code>m2dtools/basic/structure.py</code> <pre><code>def calculate_angle(v1, v2):\n    \"\"\"Calculate the angle between two vectors.\n\n    Parameters\n    ----------\n    v1 : np.ndarray\n        First vector.\n    v2 : np.ndarray\n        Second vector.\n\n    Returns\n    -------\n    float\n        Angle in degrees between ``v1`` and ``v2``.\n    \"\"\"\n    cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))\n    # convert to angle degree\n    angle = np.arccos(cos_angle)/np.pi*180\n    return angle\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.structure.pdf_sq_1type","title":"<code>pdf_sq_1type(box_size, natom, coors, r_cutoff=10, delta_r=0.01)</code>","text":"<p>Calculate PDF and SQ for a single particle type.</p>"},{"location":"references/basic/#m2dtools.basic.structure.pdf_sq_1type--parameters","title":"Parameters","text":"<p>box_size : float     Length of the cubic simulation box (\u00c5). natom : int     Number of atoms of the single particle type. coors : np.ndarray     Atomic coordinates with shape <code>(n_atoms, 3)</code>. r_cutoff : float, optional     Maximum pair distance to consider. Default is <code>10</code>. delta_r : float, optional     Bin width for the radial histogram. Default is <code>0.01</code>.</p>"},{"location":"references/basic/#m2dtools.basic.structure.pdf_sq_1type--returns","title":"Returns","text":"<p>tuple     Tuple <code>(R, g1, Q, S1)</code> where <code>R</code> are radial bin centers,     <code>g1</code> is the pair distribution, <code>Q</code> is the scattering vector,     and <code>S1</code> is the structure factor.</p> Source code in <code>m2dtools/basic/structure.py</code> <pre><code>def pdf_sq_1type(box_size, natom, coors, r_cutoff=10, delta_r=0.01):\n    \"\"\"Calculate PDF and SQ for a single particle type.\n\n    Parameters\n    ----------\n    box_size : float\n        Length of the cubic simulation box (\u00c5).\n    natom : int\n        Number of atoms of the single particle type.\n    coors : np.ndarray\n        Atomic coordinates with shape ``(n_atoms, 3)``.\n    r_cutoff : float, optional\n        Maximum pair distance to consider. Default is ``10``.\n    delta_r : float, optional\n        Bin width for the radial histogram. Default is ``0.01``.\n\n    Returns\n    -------\n    tuple\n        Tuple ``(R, g1, Q, S1)`` where ``R`` are radial bin centers,\n        ``g1`` is the pair distribution, ``Q`` is the scattering vector,\n        and ``S1`` is the structure factor.\n    \"\"\"\n    box = np.array([[box_size, 0, 0],\n                    [0, box_size, 0],\n                    [0, 0, box_size]])\n    n1 = natom\n    rcoors = np.dot(coors, np.linalg.inv(box))\n    rdis = np.zeros([natom, natom, 3])\n    for i in range(natom):\n        tmp = rcoors[i]\n        rdis[i, :, :] = tmp - rcoors\n    rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5] + 1\n    rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5] - 1\n    a = np.dot(rdis[:, :, :], box)\n    dis = np.sqrt((np.square(a[:, :, 0]) + np.square(a[:, :, 1]) + np.square(a[:, :, 2])))\n    r_max = r_cutoff\n    r = np.linspace(delta_r, r_max, int(r_max / delta_r))\n    V = np.dot(np.cross(box[1, :], box[2, :]), box[0, :])\n    rho1 = n1 / V\n    c = np.array([rho1 * rho1]) * V\n    g1 = np.histogram(dis[:n1, :n1], bins=r)[0] / (4 * np.pi *\n                                                   (r[1:] - delta_r / 2) ** 2 * delta_r * c[0])\n    R = r[1:] - delta_r / 2\n\n    dq = 0.01\n    qrange = [np.pi / 2 / r_max, 25]\n    Q = np.arange(np.floor(qrange[0] / dq), np.floor(qrange[1] / dq), 1) * dq\n    S1 = np.zeros([len(Q)])\n    rho = natom / np.dot(np.cross(box[1, :], box[2, :]), box[0, :]) #/ 10 ** 3\n    # use a window function for fourier transform\n    for i in np.arange(len(Q)):\n        S1[i] = 1 + 4 * np.pi * rho / Q[i] * np.trapz(\n            (g1 - 1) * np.sin(Q[i] * R) * R * np.sin(np.pi * R / r_max) / (np.pi * R / r_max), R)\n\n    return R, g1, Q, S1\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.structure.pdf_sq_cross","title":"<code>pdf_sq_cross(box, coors1, coors2, bond_atom_idx, r_cutoff=10, delta_r=0.01)</code>","text":"<p>Calculate PDF and SQ between two particle sets.</p>"},{"location":"references/basic/#m2dtools.basic.structure.pdf_sq_cross--parameters","title":"Parameters","text":"<p>box : np.ndarray     Simulation cell vectors as a 3x3 matrix. coors1 : np.ndarray     Coordinates of the first particle set with shape <code>(n1, 3)</code>. coors2 : np.ndarray     Coordinates of the second particle set with shape <code>(n2, 3)</code>. bond_atom_idx : array-like or None     Pairs of indices identifying bonded atoms to exclude from the     distribution. <code>None</code> disables exclusion. r_cutoff : float, optional     Maximum pair distance to consider. Default is <code>10</code>. delta_r : float, optional     Bin width for the radial histogram. Default is <code>0.01</code>.</p>"},{"location":"references/basic/#m2dtools.basic.structure.pdf_sq_cross--returns","title":"Returns","text":"<p>tuple     Tuple <code>(R, g1, Q, S1)</code> where <code>R</code> are radial bin centers,     <code>g1</code> is the pair distribution, <code>Q</code> is the scattering vector,     and <code>S1</code> is the structure factor.</p> Source code in <code>m2dtools/basic/structure.py</code> <pre><code>def pdf_sq_cross(box, coors1, coors2,  bond_atom_idx, r_cutoff:float=10, delta_r:float=0.01):\n    \"\"\"Calculate PDF and SQ between two particle sets.\n\n    Parameters\n    ----------\n    box : np.ndarray\n        Simulation cell vectors as a 3x3 matrix.\n    coors1 : np.ndarray\n        Coordinates of the first particle set with shape ``(n1, 3)``.\n    coors2 : np.ndarray\n        Coordinates of the second particle set with shape ``(n2, 3)``.\n    bond_atom_idx : array-like or None\n        Pairs of indices identifying bonded atoms to exclude from the\n        distribution. ``None`` disables exclusion.\n    r_cutoff : float, optional\n        Maximum pair distance to consider. Default is ``10``.\n    delta_r : float, optional\n        Bin width for the radial histogram. Default is ``0.01``.\n\n    Returns\n    -------\n    tuple\n        Tuple ``(R, g1, Q, S1)`` where ``R`` are radial bin centers,\n        ``g1`` is the pair distribution, ``Q`` is the scattering vector,\n        and ``S1`` is the structure factor.\n    \"\"\"\n    # check if coors1 and coors2 are exactly the same\n    if np.array_equal(coors1, coors2):\n        is_same = True\n    else:\n        is_same = False\n\n    # type_atom = np.array(type_atom)\n    n1 = len(coors1)\n    n2 = len(coors2)\n    natom = n1 + n2\n    rcoors1 = np.dot(coors1, np.linalg.inv(box))\n    rcoors2 = np.dot(coors2, np.linalg.inv(box))\n    rdis = np.zeros([n1, n2, 3])\n    for i in range(n1):\n        tmp = rcoors1[i]\n        rdis[i, :, :] = tmp - rcoors2\n    rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5] + 1\n    rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5] - 1\n    a = np.dot(rdis[:, :, :], box)\n    dis = np.sqrt((np.square(a[:, :, 0]) + np.square(a[:, :, 1]) + np.square(a[:, :, 2])))\n    # Exclude bonded atoms by setting the distances to NaN\n    if bond_atom_idx is not None:\n        for bond_pair in bond_atom_idx:\n            i1 = int(bond_pair[0])\n            i2 = int(bond_pair[1])\n            dis[i1, i2] = np.nan\n            if is_same:\n                dis[i2, i1] = np.nan\n\n    r_max = r_cutoff\n    r = np.linspace(delta_r, r_max, int(r_max / delta_r))\n    V = np.dot(np.cross(box[1, :], box[2, :]), box[0, :])\n    rho1 = n1/V\n    rho2 = n2/V\n    c = np.array([rho1 * rho2]) * V\n    g1 = np.histogram(dis, bins=r)[0] / (4 * np.pi * (r[1:] - delta_r / 2) ** 2 * delta_r * c[0])\n    R = r[1:] - delta_r / 2\n\n    dq = 0.01\n    qrange = [np.pi / 2 / r_max, 25]\n    Q = np.arange(np.floor(qrange[0] / dq), np.floor(qrange[1] / dq), 1) * dq\n    S1 = np.zeros([len(Q)])\n    rho = natom / np.dot(np.cross(box[1, :], box[2, :]), box[0, :]) #/ 10 ** 3\n    # use a window function for fourier transform\n    for i in np.arange(len(Q)):\n        S1[i] = 1 + 4 * np.pi * rho / Q[i] * np.trapz(\n            (g1 - 1) * np.sin(Q[i] * R) * R * np.sin(np.pi * R / r_max) / (np.pi * R / r_max), R)\n\n    return R, g1, Q, S1\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.structure.pdf_sq_cross_mask","title":"<code>pdf_sq_cross_mask(box, coors1, coors2, mask_matrix, r_cutoff=10, delta_r=0.01)</code>","text":"<p>Calculate PDF and SQ between two particle sets with masking.</p>"},{"location":"references/basic/#m2dtools.basic.structure.pdf_sq_cross_mask--parameters","title":"Parameters","text":"<p>box : np.ndarray     Simulation cell vectors as a 3x3 matrix. coors1 : np.ndarray     Coordinates of the first particle set with shape <code>(n1, 3)</code>. coors2 : np.ndarray     Coordinates of the second particle set with shape <code>(n2, 3)</code>. mask_matrix : np.ndarray     Matrix masking pair contributions; masked entries are ignored. r_cutoff : float, optional     Maximum pair distance to consider. Default is <code>10</code>. delta_r : float, optional     Bin width for the radial histogram. Default is <code>0.01</code>.</p>"},{"location":"references/basic/#m2dtools.basic.structure.pdf_sq_cross_mask--returns","title":"Returns","text":"<p>tuple     Tuple <code>(R, g1, Q, S1)</code> where <code>R</code> are radial bin centers,     <code>g1</code> is the pair distribution, <code>Q</code> is the scattering vector,     and <code>S1</code> is the structure factor.</p> Source code in <code>m2dtools/basic/structure.py</code> <pre><code>def pdf_sq_cross_mask(box, coors1, coors2,  mask_matrix, r_cutoff:float=10, delta_r:float=0.01):\n    \"\"\"Calculate PDF and SQ between two particle sets with masking.\n\n    Parameters\n    ----------\n    box : np.ndarray\n        Simulation cell vectors as a 3x3 matrix.\n    coors1 : np.ndarray\n        Coordinates of the first particle set with shape ``(n1, 3)``.\n    coors2 : np.ndarray\n        Coordinates of the second particle set with shape ``(n2, 3)``.\n    mask_matrix : np.ndarray\n        Matrix masking pair contributions; masked entries are ignored.\n    r_cutoff : float, optional\n        Maximum pair distance to consider. Default is ``10``.\n    delta_r : float, optional\n        Bin width for the radial histogram. Default is ``0.01``.\n\n    Returns\n    -------\n    tuple\n        Tuple ``(R, g1, Q, S1)`` where ``R`` are radial bin centers,\n        ``g1`` is the pair distribution, ``Q`` is the scattering vector,\n        and ``S1`` is the structure factor.\n    \"\"\"\n    n1 = len(coors1)\n    n2 = len(coors2)\n    natom = n1 + n2\n    rcoors1 = np.dot(coors1, np.linalg.inv(box))\n    rcoors2 = np.dot(coors2, np.linalg.inv(box))\n    rdis = np.zeros([n1, n2, 3])\n    for i in range(n1):\n        tmp = rcoors1[i]\n        rdis[i, :, :] = tmp - rcoors2\n    rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5] + 1\n    rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5] - 1\n    a = np.dot(rdis[:, :, :], box)\n    dis = np.sqrt((np.square(a[:, :, 0]) + np.square(a[:, :, 1]) + np.square(a[:, :, 2])))\n\n    dis = dis * mask_matrix\n\n    r_max = r_cutoff\n    r = np.linspace(delta_r, r_max, int(r_max / delta_r))\n    V = np.dot(np.cross(box[1, :], box[2, :]), box[0, :])\n    rho1 = n1/V\n    rho2 = n2/V\n    c = np.array([rho1 * rho2]) * V\n    g1 = np.histogram(dis, bins=r)[0] / (4 * np.pi * (r[1:] - delta_r / 2) ** 2 * delta_r * c[0])\n    R = r[1:] - delta_r / 2\n\n    dq = 0.01\n    qrange = [np.pi / 2 / r_max, 25]\n    Q = np.arange(np.floor(qrange[0] / dq), np.floor(qrange[1] / dq), 1) * dq\n    S1 = np.zeros([len(Q)])\n    rho = natom / np.dot(np.cross(box[1, :], box[2, :]), box[0, :]) #/ 10 ** 3\n    # use a window function for fourier transform\n    for i in np.arange(len(Q)):\n        S1[i] = 1 + 4 * np.pi * rho / Q[i] * np.trapz(\n            (g1 - 1) * np.sin(Q[i] * R) * R * np.sin(np.pi * R / r_max) / (np.pi * R / r_max), R)\n\n    return R, g1, Q, S1\n</code></pre>"},{"location":"references/basic/#dynamics","title":"Dynamics","text":"<p>Dynamic analysis routines for trajectory data.</p>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_D","title":"<code>compute_D(time, msd, fit_from=0, dim=3)</code>","text":"<p>Compute the diffusion coefficient from an MSD curve.</p>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_D--parameters","title":"Parameters","text":"<p>time : np.ndarray     Time values corresponding to the MSD entries. msd : np.ndarray     Mean-squared displacement values. fit_from : int, optional     Index at which to start the linear regression. Default is <code>0</code>. dim : int, optional     Dimensionality of the system (e.g., <code>3</code> for 3D). Default is <code>3</code>.</p>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_D--returns","title":"Returns","text":"<p>float     Estimated diffusion coefficient in units of <code>msd/time</code>.</p> Source code in <code>m2dtools/basic/dynamics.py</code> <pre><code>def compute_D(time, msd, fit_from=0, dim=3):\n    \"\"\"Compute the diffusion coefficient from an MSD curve.\n\n    Parameters\n    ----------\n    time : np.ndarray\n        Time values corresponding to the MSD entries.\n    msd : np.ndarray\n        Mean-squared displacement values.\n    fit_from : int, optional\n        Index at which to start the linear regression. Default is ``0``.\n    dim : int, optional\n        Dimensionality of the system (e.g., ``3`` for 3D). Default is ``3``.\n\n    Returns\n    -------\n    float\n        Estimated diffusion coefficient in units of ``msd/time``.\n    \"\"\"\n    coeffs = np.polyfit(time[fit_from:], msd[fit_from:], 1)\n    D = coeffs[0] / 2 / dim # in unit of msd / time\n    return D\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_SISF","title":"<code>compute_SISF(positions, box_lengths, lag_array, k, num_vectors=100, n_repeat=100)</code>","text":"<p>Compute the self-intermediate scattering function (SISF).</p>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_SISF--parameters","title":"Parameters","text":"<p>positions : np.ndarray     Atom positions with shape <code>(n_frames, n_atoms, 3)</code>. box_lengths : np.ndarray or list     Simulation box lengths per frame with shape <code>(n_frames, 3)</code>. lag_array : np.ndarray or list     Lag times (in frames) at which to evaluate the SISF. k : float     Magnitude of the wave vector <code>|k|</code>. num_vectors : int, optional     Number of random <code>k</code>-vectors to sample. Default is <code>100</code>. n_repeat : int, optional     Number of time origins to average over. Default is <code>100</code>.</p>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_SISF--returns","title":"Returns","text":"<p>np.ndarray     Self-intermediate scattering values for each lag time.</p> Source code in <code>m2dtools/basic/dynamics.py</code> <pre><code>def compute_SISF(positions, box_lengths, lag_array, k, num_vectors=100, n_repeat=100):\n    \"\"\"Compute the self-intermediate scattering function (SISF).\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        Atom positions with shape ``(n_frames, n_atoms, 3)``.\n    box_lengths : np.ndarray or list\n        Simulation box lengths per frame with shape ``(n_frames, 3)``.\n    lag_array : np.ndarray or list\n        Lag times (in frames) at which to evaluate the SISF.\n    k : float\n        Magnitude of the wave vector ``|k|``.\n    num_vectors : int, optional\n        Number of random ``k``-vectors to sample. Default is ``100``.\n    n_repeat : int, optional\n        Number of time origins to average over. Default is ``100``.\n\n    Returns\n    -------\n    np.ndarray\n        Self-intermediate scattering values for each lag time.\n    \"\"\"\n    n_frames, n_atoms, _ = positions.shape\n\n    # Unwrap positions considering periodic boundary conditions\n    unwrapped_pos = np.zeros_like(positions)\n    unwrapped_pos[0] = positions[0]\n\n    for t in range(1, n_frames):\n        box_length_tmp = (box_lengths[t] + box_lengths[t - 1]) / 2\n        delta = positions[t] - unwrapped_pos[t - 1]\n        delta -= box_length_tmp * np.round(delta / box_length_tmp)\n        unwrapped_pos[t] = unwrapped_pos[t - 1] + delta\n\n    sisf = np.zeros(len(lag_array))\n    vectors=random_vectors(k, num_vectors)\n\n    for i, lag in enumerate(lag_array):\n        if len(positions)-lag &lt; n_repeat:\n            displacements = unwrapped_pos[lag:] - unwrapped_pos[:-lag]\n            #compute cos(k*r) for each random vector and average\n            cos_kr = np.cos(np.einsum('ij,tkj-&gt;tki', vectors, displacements))\n        else:\n            random_indices = np.random.choice(len(positions)-lag, n_repeat)\n            displacements = unwrapped_pos[lag + random_indices] - unwrapped_pos[random_indices]\n            cos_kr = np.cos(np.einsum('ij,tkj-&gt;tki', vectors, displacements))\n        sisf[i] = np.mean(cos_kr)\n    return sisf\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_SISF_zresolved","title":"<code>compute_SISF_zresolved(positions, box_lengths, lag_array, k, z_ranges, num_vectors=100, n_repeat=100)</code>","text":"<p>Layer-resolved SISF with z-bin assignment performed at every time origin t0.</p>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_SISF_zresolved--parameters","title":"Parameters","text":"<p>z_ranges : list of tuple     List of (zmin, zmax) tuples defining the layers along z-axis. Other parameters are the same as in <code>compute_SISF</code>.</p>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_SISF_zresolved--returns","title":"Returns","text":"<p>np.ndarray     Self-intermediate scattering values for each layer and lag time.</p> Source code in <code>m2dtools/basic/dynamics.py</code> <pre><code>def compute_SISF_zresolved(positions, box_lengths, lag_array, k,\n                            z_ranges,\n                            num_vectors=100, n_repeat=100) -&gt; np.ndarray:\n    \"\"\"\n    Layer-resolved SISF with z-bin assignment performed at every time origin t0.\n\n    Parameters\n    ----------\n    z_ranges : list of tuple\n        List of (zmin, zmax) tuples defining the layers along z-axis.\n    Other parameters are the same as in `compute_SISF`.\n\n    Returns\n    -------\n    np.ndarray\n        Self-intermediate scattering values for each layer and lag time.\n    \"\"\"\n\n    n_frames, n_atoms, _ = positions.shape\n    n_layers = len(z_ranges)\n\n    # ---- unwrap ----\n    unwrapped = np.zeros_like(positions)\n    unwrapped[0] = positions[0]\n\n    for t in range(1, n_frames):\n        box_tmp = 0.5 * (box_lengths[t] + box_lengths[t-1])\n        delta = positions[t] - unwrapped[t-1]\n        delta -= box_tmp * np.round(delta / box_tmp)\n        unwrapped[t] = unwrapped[t-1] + delta\n\n    # ---- random k vectors ----\n    vectors = random_vectors_2D(k, num_vectors)\n\n    # ---- output ----\n    sisf_layers = np.zeros((n_layers, len(lag_array)))\n\n    # ---- compute for each lag ----\n    for i, lag in enumerate(lag_array):\n\n        max_origin = n_frames - lag\n        if max_origin &lt; n_repeat:\n            origins = np.arange(max_origin)\n        else:\n            origins = np.random.choice(max_origin, n_repeat, replace=False)\n\n        # accumulator for each layer\n        accum = [ [] for _ in range(n_layers) ]\n\n        for t0 in origins:\n            z_now = unwrapped[t0, :, 2]   # z positions at time origin\n\n            # assign atoms at this time origin\n            atom_layers = []\n            for (zmin, zmax) in z_ranges:\n                atom_layers.append(np.where((z_now &gt;= zmin) &amp; (z_now &lt; zmax))[0])\n\n            # compute displacements from t0 to t0+lag\n            disp = unwrapped[t0 + lag] - unwrapped[t0]   # (N,3)\n\n            for L, atoms_L in enumerate(atom_layers):\n                if len(atoms_L) == 0:\n                    continue\n\n                d = disp[atoms_L]           # (n_atoms_L, 3)\n\n                cos_kr = np.cos(np.einsum(\"ij,nj-&gt;ni\", vectors, d))\n                accum[L].append(np.mean(cos_kr))\n\n        # average for each layer\n        for L in range(n_layers):\n            if len(accum[L]) &gt; 0:\n                sisf_layers[L, i] = np.mean(accum[L])\n\n    return sisf_layers\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_msd_pbc","title":"<code>compute_msd_pbc(positions, box_lengths, lag_array)</code>","text":"<p>Compute mean-squared displacement with periodic boundaries.</p>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_msd_pbc--parameters","title":"Parameters","text":"<p>positions : np.ndarray     Atom positions with shape <code>(n_frames, n_atoms, 3)</code>. box_lengths : np.ndarray or list     Simulation box lengths per frame with shape <code>(n_frames, 3)</code>. lag_array : np.ndarray or list     Lag times (in frames) at which to evaluate the MSD.</p>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_msd_pbc--returns","title":"Returns","text":"<p>np.ndarray     Mean-squared displacement values for each lag time.</p> Source code in <code>m2dtools/basic/dynamics.py</code> <pre><code>def compute_msd_pbc(positions, box_lengths, lag_array):\n    \"\"\"Compute mean-squared displacement with periodic boundaries.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        Atom positions with shape ``(n_frames, n_atoms, 3)``.\n    box_lengths : np.ndarray or list\n        Simulation box lengths per frame with shape ``(n_frames, 3)``.\n    lag_array : np.ndarray or list\n        Lag times (in frames) at which to evaluate the MSD.\n\n    Returns\n    -------\n    np.ndarray\n        Mean-squared displacement values for each lag time.\n    \"\"\"\n    n_frames, n_atoms, _ = positions.shape\n\n    # Unwrap positions considering periodic boundary conditions\n    unwrapped_pos = np.zeros_like(positions)\n    unwrapped_pos[0] = positions[0]\n\n    for t in range(1, n_frames):\n        box_length_tmp = (box_lengths[t] + box_lengths[t - 1]) / 2\n        delta = positions[t] - unwrapped_pos[t - 1]\n        delta -= box_length_tmp * np.round(delta / box_length_tmp)\n        unwrapped_pos[t] = unwrapped_pos[t - 1] + delta\n\n    msd = np.zeros(len(lag_array))\n\n    for i, lag in enumerate(lag_array):\n        displacements = unwrapped_pos[lag:] - unwrapped_pos[:-lag]\n        squared_displacements = np.sum(displacements**2, axis=2)\n        msd[i] = np.mean(squared_displacements)\n\n    return msd\n</code></pre>"},{"location":"references/basic/#basic","title":"Basic","text":"<p>Basic analysis utilities for molecular dynamics trajectories.</p> <p>This module gathers small helper routines for coordination numbers, angle distributions, compressibility, and force autocorrelations.</p>"},{"location":"references/basic/#m2dtools.basic.basic.CN","title":"<code>CN(box, coors, cutoff)</code>","text":"<p>Compute coordination numbers within a cutoff.</p>"},{"location":"references/basic/#m2dtools.basic.basic.CN--parameters","title":"Parameters","text":"<p>box : np.ndarray     Simulation cell vectors as a 3x3 matrix. coors : np.ndarray     Atomic coordinates with shape <code>(n_atoms, 3)</code>. cutoff : float     Distance cutoff for neighbor identification.</p>"},{"location":"references/basic/#m2dtools.basic.basic.CN--returns","title":"Returns","text":"<p>tuple     A tuple <code>(CN, CN_idx, CN_dist, diff)</code> containing coordination     counts, neighbor indices, neighbor distances, and displacement     vectors under periodic boundary conditions.</p> Source code in <code>m2dtools/basic/basic.py</code> <pre><code>def CN(box, coors, cutoff):\n    \"\"\"Compute coordination numbers within a cutoff.\n\n    Parameters\n    ----------\n    box : np.ndarray\n        Simulation cell vectors as a 3x3 matrix.\n    coors : np.ndarray\n        Atomic coordinates with shape ``(n_atoms, 3)``.\n    cutoff : float\n        Distance cutoff for neighbor identification.\n\n    Returns\n    -------\n    tuple\n        A tuple ``(CN, CN_idx, CN_dist, diff)`` containing coordination\n        counts, neighbor indices, neighbor distances, and displacement\n        vectors under periodic boundary conditions.\n    \"\"\"\n\n    rcoors = np.dot(coors, np.linalg.inv(box))\n\n    r1 = rcoors[:, np.newaxis, :]\n    r2 = rcoors[np.newaxis, :, :]\n\n    rdis = r1-r2\n\n    while np.sum((rdis &lt; -0.5) | (rdis &gt; 0.5)) &gt; 0:\n        rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5]+1\n        rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5]-1\n\n    diff = np.dot(rdis, box)\n\n    dis = np.sqrt(np.sum(np.square(diff), axis=2))\n\n    CN_idx = []\n    CN_dist = []\n    CN = np.zeros(coors.shape[0])\n    for i in range(coors.shape[0]):\n        tmp = np.argwhere((dis[i, :] &lt; cutoff) &amp; (dis[i, :] &gt; 0))\n        CN[i] = tmp.shape[0]\n        CN_idx.append(tmp)\n        CN_dist.append(dis[i, (dis[i, :] &lt; cutoff) &amp; (dis[i, :] &gt; 0)])\n    return CN, CN_idx, CN_dist, diff\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.basic.CN_large","title":"<code>CN_large(box, coors, cutoff)</code>","text":"<p>Compute coordination numbers for large systems.</p>"},{"location":"references/basic/#m2dtools.basic.basic.CN_large--parameters","title":"Parameters","text":"<p>box : np.ndarray     Simulation cell vectors as a 3x3 matrix. coors : np.ndarray     Atomic coordinates with shape <code>(n_atoms, 3)</code>. cutoff : float     Distance cutoff for neighbor identification.</p>"},{"location":"references/basic/#m2dtools.basic.basic.CN_large--returns","title":"Returns","text":"<p>tuple     A tuple <code>(CN, CN_idx, CN_dist)</code> with coordination counts,     neighbor indices, and neighbor distances for each atom.</p> Source code in <code>m2dtools/basic/basic.py</code> <pre><code>def CN_large(box, coors, cutoff):\n    \"\"\"Compute coordination numbers for large systems.\n\n    Parameters\n    ----------\n    box : np.ndarray\n        Simulation cell vectors as a 3x3 matrix.\n    coors : np.ndarray\n        Atomic coordinates with shape ``(n_atoms, 3)``.\n    cutoff : float\n        Distance cutoff for neighbor identification.\n\n    Returns\n    -------\n    tuple\n        A tuple ``(CN, CN_idx, CN_dist)`` with coordination counts,\n        neighbor indices, and neighbor distances for each atom.\n    \"\"\"\n    CN = []\n    CN_idx = []\n    CN_dist = []\n    for i in range(coors.shape[0]):\n        # find atom in the cubic at the center of coord[1], within the cutoff\n        coord0 = coors[i]\n        diff_coord = coors - coord0\n        # periodic boundary condition\n        diff_coord = diff_coord - np.round(diff_coord @ np.linalg.inv(box) ) @ box\n        idx_interest = np.argwhere((diff_coord[:, 0] &gt;= -cutoff)*(diff_coord[:, 0] &lt;= cutoff)*(diff_coord[:, 1] &gt;= -cutoff)*(diff_coord[:, 1] &lt;= cutoff)*(diff_coord[:, 2] &gt;= -cutoff)*(diff_coord[:, 2] &lt;= cutoff)).flatten()\n        dist_tmp = np.linalg.norm(diff_coord[idx_interest,:], axis=1)\n        idx_CN_tmp = np.argwhere(dist_tmp&lt;=cutoff).flatten()\n        CN.append(idx_CN_tmp.shape[0])\n        CN_idx.append(idx_interest[idx_CN_tmp])\n        CN_dist.append(dist_tmp[idx_CN_tmp])\n    return CN, CN_idx, CN_dist\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.basic.calc_compressibility","title":"<code>calc_compressibility(V, T=300)</code>","text":"<p>Calculate the isothermal compressibility from volume fluctuations.</p>"},{"location":"references/basic/#m2dtools.basic.basic.calc_compressibility--parameters","title":"Parameters","text":"<p>V : np.ndarray     Array of volume samples in nm^3. T : float, optional     Temperature in Kelvin. Default is 300 K.</p>"},{"location":"references/basic/#m2dtools.basic.basic.calc_compressibility--returns","title":"Returns","text":"<p>float     Isothermal compressibility in <code>1/Pa</code>.</p> Source code in <code>m2dtools/basic/basic.py</code> <pre><code>def calc_compressibility(V, T=300):\n    \"\"\"Calculate the isothermal compressibility from volume fluctuations.\n\n    Parameters\n    ----------\n    V : np.ndarray\n        Array of volume samples in nm^3.\n    T : float, optional\n        Temperature in Kelvin. Default is 300 K.\n\n    Returns\n    -------\n    float\n        Isothermal compressibility in ``1/Pa``.\n    \"\"\"\n    kB = 1.380649e-23  # J/K\n    V = V * 1e-27  # Convert from nm^3 to m^3\n    kappa_T = np.var(V) / (V.mean() * kB * T)\n    return kappa_T * 1e9 # to 1/GPa\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.basic.compute_autocorrelation","title":"<code>compute_autocorrelation(forces, max_lag)</code>","text":"<p>Compute the force autocorrelation function (FAF).</p>"},{"location":"references/basic/#m2dtools.basic.basic.compute_autocorrelation--parameters","title":"Parameters","text":"<p>forces : np.ndarray     Array of shape <code>(n_frames, n_atoms, 3)</code> containing forces per     atom. max_lag : int     Maximum lag time (in frames) for computing the autocorrelation.</p>"},{"location":"references/basic/#m2dtools.basic.basic.compute_autocorrelation--returns","title":"Returns","text":"<p>np.ndarray     Force autocorrelation values with length <code>max_lag</code>.</p> Source code in <code>m2dtools/basic/basic.py</code> <pre><code>def compute_autocorrelation(forces, max_lag):\n    \"\"\"Compute the force autocorrelation function (FAF).\n\n    Parameters\n    ----------\n    forces : np.ndarray\n        Array of shape ``(n_frames, n_atoms, 3)`` containing forces per\n        atom.\n    max_lag : int\n        Maximum lag time (in frames) for computing the autocorrelation.\n\n    Returns\n    -------\n    np.ndarray\n        Force autocorrelation values with length ``max_lag``.\n    \"\"\"\n    n_frames, n_atoms, _ = forces.shape\n\n    # Initialize autocorrelation array\n    faf = np.zeros(max_lag)\n\n    # Loop over lag times\n    for lag in range(max_lag):\n        # Compute dot product of forces separated by lag\n        dot_products = np.sum(forces[:n_frames - lag] * forces[lag:], axis=(1, 2))\n        faf[lag] = np.mean(dot_products)\n\n    # Normalize by the zero-lag correlation\n    faf /= faf[0]\n\n    return faf\n</code></pre>"},{"location":"references/lmp/","title":"lmp","text":"<p>Tools for reading and writing LAMMPS data files and dumps.</p>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.angle_distribution","title":"<code>angle_distribution(coors, box, cutoff)</code>","text":"<p>compute O-O-O angle distribution in water within a cutoff distance inputs: coors, box, cutoff outputs: angles</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def angle_distribution(coors, box, cutoff):\n    \"\"\"\n    compute O-O-O angle distribution in water within a cutoff distance\n    inputs: coors, box, cutoff\n    outputs: angles\n    \"\"\"\n    n_atom = coors.shape[0]\n    angles = []\n    rcoors = np.dot(coors, np.linalg.inv(box))\n    rdis = np.zeros([n_atom, n_atom, 3])\n    for i in range(n_atom):\n        tmp = rcoors[i]\n        rdis[i, :, :] = tmp - rcoors\n    rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5] + 1\n    rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5] - 1\n    a = np.dot(rdis[:, :, :], box)\n    dis = np.sqrt((np.square(a[:, :, 0]) + np.square(a[:, :, 1]) + np.square(a[:, :, 2])))\n\n    for i in range(n_atom):\n        for j in np.arange(i+1, n_atom):\n            for k in np.arange(j+1, n_atom):\n                if dis[i, j] &lt; cutoff and dis[i, k] &lt; cutoff and dis[j, k] &lt; cutoff:\n                    angle = calculate_angle(a[j, i, :], a[k, i, :])\n                    angles.append(angle)\n                    angle = calculate_angle(a[i, j, :], a[k, j, :])\n                    angles.append(angle)\n                    angle = calculate_angle(a[i, k, :], a[j, k, :])\n                    angles.append(angle)\n    return angles\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.average_log","title":"<code>average_log(log_files, freq=1)</code>","text":"<p>Average the log data from multiple files. Parameters:     log_files: list of str         List of log file names.     freq: int         Frequency of the data to be read. Returns:     df_mean: pd.DataFrame         DataFrame of mean values.     df_std: pd.DataFrame         DataFrame of standard deviation values.</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def average_log(log_files, freq=1):\n    \"\"\"\n    Average the log data from multiple files.\n    Parameters:\n        log_files: list of str\n            List of log file names.\n        freq: int\n            Frequency of the data to be read.\n    Returns:\n        df_mean: pd.DataFrame\n            DataFrame of mean values.\n        df_std: pd.DataFrame\n            DataFrame of standard deviation values.\n    \"\"\"\n    dfs = []\n    for i, log_file in enumerate(log_files):\n        log = read_log_lammps(log_file, freq=freq)[-1]\n        dfs.append(log)\n\n    # Stack into a 3D array (frames \u00d7 rows \u00d7 columns)\n    stacked = pd.concat(dfs, keys=range(len(dfs)))  # adds outer index (frame index)\n\n    # Compute mean and std over the first level (i.e., over frames)\n    df_mean = stacked.groupby(level=1).mean()\n    df_std = stacked.groupby(level=1).std()\n    return df_mean, df_std\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.calc_compressibility","title":"<code>calc_compressibility(V, T=300)</code>","text":"<p>Calculate compressibility from volume and temperature. :param V: Volume in nm^3 :param T: Temperature in K :return: Compressibility in 1/Pa</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def calc_compressibility(V, T=300):\n    \"\"\"\n    Calculate compressibility from volume and temperature.\n    :param V: Volume in nm^3\n    :param T: Temperature in K\n    :return: Compressibility in 1/Pa\n    \"\"\"\n    kB = 1.380649e-23  # J/K\n    V = V * 1e-27  # Convert from nm^3 to m^3\n    kappa_T = np.var(V) / (V.mean() * kB * T)\n    return kappa_T * 1e9 # to 1/GPa\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.calculate_angle","title":"<code>calculate_angle(v1, v2)</code>","text":"<p>Calculate the angle between two vectors.</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def calculate_angle(v1, v2):\n    \"\"\"Calculate the angle between two vectors.\"\"\"\n    cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))\n    # convert to angle degree\n    angle = np.arccos(cos_angle)/np.pi*180\n    return angle\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.compute_autocorrelation","title":"<code>compute_autocorrelation(forces, max_lag)</code>","text":"<p>Compute the force autocorrelation function (FAF).</p>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.compute_autocorrelation--parameters","title":"Parameters:","text":"<p>forces : np.ndarray     Array of shape (n_frames, n_atoms, 3), forces per atom. max_lag : int     Maximum lag time (in frames) for computing the autocorrelation.</p>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.compute_autocorrelation--returns","title":"Returns:","text":"<p>faf : np.ndarray     Force autocorrelation function as a 1D array of length max_lag.</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def compute_autocorrelation(forces, max_lag):\n    \"\"\"\n    Compute the force autocorrelation function (FAF).\n\n    Parameters:\n    -----------\n    forces : np.ndarray\n        Array of shape (n_frames, n_atoms, 3), forces per atom.\n    max_lag : int\n        Maximum lag time (in frames) for computing the autocorrelation.\n\n    Returns:\n    --------\n    faf : np.ndarray\n        Force autocorrelation function as a 1D array of length max_lag.\n    \"\"\"\n    n_frames, n_atoms, _ = forces.shape\n\n    # Initialize autocorrelation array\n    faf = np.zeros(max_lag)\n\n    # Loop over lag times\n    for lag in range(max_lag):\n        # Compute dot product of forces separated by lag\n        dot_products = np.sum(forces[:n_frames - lag] * forces[lag:], axis=(1, 2))\n        faf[lag] = np.mean(dot_products)\n\n    # Normalize by the zero-lag correlation\n    faf /= faf[0]\n\n    return faf\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.compute_msd_pbc","title":"<code>compute_msd_pbc(positions, box_lengths, lag_array)</code>","text":"<p>Compute mean-squared displacement (MSD) considering periodic boundary conditions.</p>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.compute_msd_pbc--parameters","title":"Parameters:","text":"<p>positions : np.ndarray     Atom positions array of shape (n_frames, n_atoms, 3). box_lengths : np.ndarray or list     Simulation box lengths of shape (n_frames, 3). lag_array : np.ndarray or list     Array of lag times for which to compute the MSD.</p>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.compute_msd_pbc--returns","title":"Returns:","text":"<p>msd : np.ndarray     Mean-squared displacement as 1D array of length max_lag.</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def compute_msd_pbc(positions, box_lengths, lag_array):\n    \"\"\"\n    Compute mean-squared displacement (MSD) considering periodic boundary conditions.\n\n    Parameters:\n    -----------\n    positions : np.ndarray\n        Atom positions array of shape (n_frames, n_atoms, 3).\n    box_lengths : np.ndarray or list\n        Simulation box lengths of shape (n_frames, 3).\n    lag_array : np.ndarray or list\n        Array of lag times for which to compute the MSD.\n\n    Returns:\n    --------\n    msd : np.ndarray\n        Mean-squared displacement as 1D array of length max_lag.\n    \"\"\"\n    n_frames, n_atoms, _ = positions.shape\n\n    # Unwrap positions considering periodic boundary conditions\n    unwrapped_pos = np.zeros_like(positions)\n    unwrapped_pos[0] = positions[0]\n\n    for t in range(1, n_frames):\n        box_length_tmp = (box_lengths[t] + box_lengths[t - 1]) / 2\n        delta = positions[t] - unwrapped_pos[t - 1]\n        delta -= box_length_tmp * np.round(delta / box_length_tmp)\n        unwrapped_pos[t] = unwrapped_pos[t - 1] + delta\n\n    msd = np.zeros(len(lag_array))\n\n    for i, lag in enumerate(lag_array):\n        displacements = unwrapped_pos[lag:] - unwrapped_pos[:-lag]\n        squared_displacements = np.sum(displacements**2, axis=2)\n        msd[i] = np.mean(squared_displacements)\n\n    return msd\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.distance_pbc","title":"<code>distance_pbc(coord1, coord2, box)</code>","text":"<p>Calculate the pairwise distances between sets of atoms in a box with periodic boundary conditions.</p> <p>Parameters: - coord1 (np.ndarray): A (N x 3) array of coordinates for N atoms. - coord2 (np.ndarray): A (M x 3) array of coordinates for M atoms. - box (np.ndarray): A (3 x 3) array representing the box vectors.</p> <p>Returns: - dist_matrix (np.ndarray): An (N x M) matrix of distances.</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def distance_pbc(coord1, coord2, box):\n    \"\"\"\n    Calculate the pairwise distances between sets of atoms in a box with periodic boundary conditions.\n\n    Parameters:\n    - coord1 (np.ndarray): A (N x 3) array of coordinates for N atoms.\n    - coord2 (np.ndarray): A (M x 3) array of coordinates for M atoms.\n    - box (np.ndarray): A (3 x 3) array representing the box vectors.\n\n    Returns:\n    - dist_matrix (np.ndarray): An (N x M) matrix of distances.\n    \"\"\"\n    # Expand coord1 and coord2 to (N, 1, 3) and (1, M, 3) respectively to broadcast subtraction\n    delta = coord1[:, np.newaxis, :] - coord2[np.newaxis, :, :]\n\n    # Compute box inversions and apply periodic boundary conditions\n    delta -= np.round(delta @ np.linalg.inv(box)) @ box\n\n    # Compute the Euclidean distance\n    dist_matrix = np.linalg.norm(delta, axis=-1)\n\n    return dist_matrix\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.dump2str","title":"<code>dump2str(save_file, dump_file, sample_file, idx)</code>","text":"<p>convert the dump file to lammps structure file</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def dump2str(save_file: str,\n             dump_file: str,\n             sample_file: str,\n             idx: int or list):\n    \"\"\"\n    convert the dump file to lammps structure file\n    \"\"\"\n    lmp = read_lammps_full(sample_file)\n    lmp.atom_info = lmp.atom_info[np.argsort(lmp.atom_info[:, 0])]\n    frame_list, t_list, L_list = read_lammps_dump_custom(dump_file)\n    lmp_new = copy.copy(lmp)\n\n    if type(idx) == int:\n        idx = [idx]\n    for id in idx:\n        lmp_new.x = L_list[id][0]\n        lmp_new.y = L_list[id][1]\n        lmp_new.z = L_list[id][2]\n\n        coors = frame_list[id].loc[:, ['x', 'y', 'z']].values\n        lmp_new.atom_info[:, 4:7] = coors\n        write_lammps_full(save_file + f'{id}', lmp_new)\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.read_lammps_dump_custom","title":"<code>read_lammps_dump_custom(dump_file, interval=1)</code>","text":"<p>input: dump_file output: frame, t_list, L_list</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def read_lammps_dump_custom(dump_file, interval=1):\n    \"\"\"\n    input: dump_file\n    output: frame, t_list, L_list\n    \"\"\"\n    t_list = []\n    frame = []\n    L_list = []\n    frame_count = 0\n\n    with open(dump_file, 'r') as f:\n        for line in f:\n            if line.startswith('ITEM: TIMESTEP'):\n                frame_count += 1\n                timestep = int(next(f).split()[0])\n\n                # Only process and store the frame if frame_count is a multiple of the interval\n                if frame_count % interval == 0:\n                    t_list.append(timestep)\n                    store_frame = True\n                else:\n                    store_frame = False\n\n            if line.startswith('ITEM: NUMBER OF ATOMS') and store_frame:\n                natoms = int(next(f).split()[0])\n\n            if line.startswith('ITEM: BOX') and store_frame:\n                lx = [float(x) for x in next(f).split()[:2]]\n                ly = [float(x) for x in next(f).split()[:2]]\n                lz = [float(x) for x in next(f).split()[:2]]\n                L_list.append([lx, ly, lz])\n\n            if line.startswith('ITEM: ATOMS') and store_frame:\n                columns = line.split()[2:]\n                data = []\n                for i in range(natoms):\n                    line_data = []\n                    raw_fields = [x for x in next(f).split() if x.strip()]\n                    for x in raw_fields[:len(columns)]:\n                        try:\n                            line_data.append(float(x))\n                        except ValueError:\n                            line_data.append(str(x))\n                    data.append(line_data)\n                    # data.append([float(x) for x in next(f).split()])\n                df = pd.DataFrame(data, columns=columns)\n                df_sorted = df.sort_values(by=['id'])\n                frame.append(df_sorted)\n\n    return frame, t_list, L_list\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.read_log_lammps","title":"<code>read_log_lammps(logfile, freq=1)</code>","text":"<p>read the log file and return the list of dataframes parameters:     logfile: str         log file name     freq: int         frequency of the data to be read return:     data_list: list         list of dataframes</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def read_log_lammps(logfile, freq=1):\n    \"\"\"\n    read the log file and return the list of dataframes\n    parameters:\n        logfile: str\n            log file name\n        freq: int\n            frequency of the data to be read\n    return:\n        data_list: list\n            list of dataframes\n    \"\"\"\n    f = open(logfile, 'r')\n    L = f.readlines()\n    f.close()\n    l1_list, l2_list = [], []\n    for i in range(len(L)):\n        if ('Step' in L[i]) and ('Temp' in L[i]):\n            l1_list.append(i)\n        if 'Loop time' in L[i]:\n            l2_list.append(i)\n    if len(l2_list) == 0:\n        l2_list.append(len(L)-1)\n    # print(l1_list, l2_list)\n    data_list = []\n    for i, l1 in enumerate(l1_list):\n        l2 = l2_list[i]\n        data = np.array(L[l1+1].split())\n        for i in range(l1+1, l2, freq):\n            data = np.vstack((data, L[i].split()))\n        data = pd.DataFrame(data, dtype='float64', columns=L[l1].split())\n        data_list.append(data)\n    return data_list\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.read_table_pot","title":"<code>read_table_pot(file_name, key_words)</code>","text":"<p>input: file_name, key_words output: r, e_pot, f_pot</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def read_table_pot(file_name, key_words):\n    \"\"\"\n    input: file_name, key_words\n    output: r, e_pot, f_pot\n    \"\"\"\n    r = []\n    e_pot = []\n    f_pot = []\n    with open(file_name, 'r') as f:\n        while True:\n            line = f.readline()\n            if key_words in line:\n                meta_info = f.readline()\n                f.readline()\n                for i in range(int(meta_info.split()[1])):\n                    line = f.readline()\n                    data = line.split()\n                    r.append(float(data[1]))\n                    e_pot.append(float(data[2]))\n                    f_pot.append(float(data[3]))\n                break\n    r = np.array(r)\n    e_pot = np.array(e_pot)\n    f_pot = np.array(f_pot)\n    return r, e_pot, f_pot\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.wrap_mol","title":"<code>wrap_mol(save_file, input_file)</code>","text":"<p>wrap the molecule in the box, make sure the atoms in the same mol are in the same image</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def wrap_mol(save_file: str,\n             input_file: str):\n    \"\"\"\n    wrap the molecule in the box, make sure the atoms in the same mol are in the same image\n    \"\"\"\n\n    lmp = read_lammps_full(input_file)\n    lmp.atom_info = lmp.atom_info[np.argsort(lmp.atom_info[:, 0])]\n    lmp_new = copy.copy(lmp)\n    box_size = lmp.x[1] - lmp.x[0]  # assume cubic for now\n\n    mol_id = lmp.atom_info[:, 1]\n    mol_list = np.unique(mol_id)\n\n    for mol in mol_list:\n        idx = np.argwhere(mol_id == mol).flatten()\n        coors = lmp.atom_info[idx, 4:7]\n        rcoors = coors - coors[0]\n        rcoors = rcoors - np.round(rcoors/box_size)*box_size\n        coors = coors[0] + rcoors\n        lmp_new.atom_info[idx, 4:7] = coors\n\n    write_lammps_full(save_file, lmp_new)\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.write_lammps","title":"<code>write_lammps(file_name, lmp_tmp, mode='full')</code>","text":"<p>input: file_name,lmp_tmp lmp_tmp is a an instance of lammps class with full attributes, must contain natoms, natom_types, x, y, z, atom_info, mass, pair_coeff optionally contain</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def write_lammps(file_name, lmp_tmp, mode='full'):\n    \"\"\"\n    input: file_name,lmp_tmp\n    lmp_tmp is a an instance of lammps class with full attributes,\n    must contain natoms, natom_types, x, y, z, atom_info, mass, pair_coeff\n    optionally contain\n    \"\"\"\n    with open('{}'.format(file_name), 'w') as f:\n        f.write('Generated by ZYMD\\n\\n')\n\n        f.write('{} atoms\\n'.format(lmp_tmp.natoms))\n        f.write('{} atom types\\n'.format(lmp_tmp.natom_types))\n        f.write('{} bonds\\n'.format(lmp_tmp.nbonds))\n        f.write('{} bond types\\n'.format(lmp_tmp.nbond_types))\n        f.write('{} angles\\n'.format(lmp_tmp.nangles))\n        f.write('{} angle types\\n'.format(lmp_tmp.nangle_types))\n        f.write('{} dihedrals\\n'.format(lmp_tmp.ndihedrals))\n        f.write('{} dihedral types\\n'.format(lmp_tmp.ndihedral_types))\n        f.write('{} impropers\\n'.format(lmp_tmp.nimpropers))\n        f.write('{} improper types\\n'.format(lmp_tmp.nimproper_types))\n        f.write('\\n')\n\n        f.write('{0:.16f} {1:.16f} xlo xhi\\n'.format(lmp_tmp.x[0], lmp_tmp.x[1]))\n        f.write('{0:.16f} {1:.16f} ylo yhi\\n'.format(lmp_tmp.y[0], lmp_tmp.y[1]))\n        f.write('{0:.16f} {1:.16f} zlo zhi\\n'.format(lmp_tmp.z[0], lmp_tmp.z[1]))\n        f.write('\\n')\n\n        f.write('Masses\\n\\n')\n        for i in range(len(lmp_tmp.mass)):\n            if lmp_tmp.mass.shape[1] == 3:\n                f.write('{0:d} {1:.3f} # {2:s}\\n'.format(\n                    int(float(lmp_tmp.mass[i, 0])), float(lmp_tmp.mass[i, 1]), lmp_tmp.mass[i, 2]))\n            elif lmp_tmp.mass.shape[1] == 2:\n                f.write('{0:d} {1:.3f}\\n'.format(\n                    int(float(lmp_tmp.mass[i, 0])), float(lmp_tmp.mass[i, 1])))\n        f.write('\\n')\n\n        if hasattr(lmp_tmp, 'pair_coeff') and not (lmp_tmp.pair_coeff is None):\n            f.write('Pair Coeffs\\n\\n')\n            for i in range(len(lmp_tmp.pair_coeff)):\n                f.write('{0:d} {1:f} {2:f}\\n'.format(\n                    int(lmp_tmp.pair_coeff[i, 0]), lmp_tmp.pair_coeff[i, 1], lmp_tmp.pair_coeff[i, 2]))\n            f.write('\\n')\n\n        if hasattr(lmp_tmp, 'bond_coeff') and not (lmp_tmp.bond_coeff is None):\n            f.write('Bond Coeffs\\n\\n')\n            for i in range(len(lmp_tmp.bond_coeff)):\n                f.write('{0:d} {1:f} {2:f}\\n'.format(\n                    int(lmp_tmp.bond_coeff[i, 0]), lmp_tmp.bond_coeff[i, 1], lmp_tmp.bond_coeff[i, 2]))\n            f.write('\\n')\n\n        if hasattr(lmp_tmp, 'angle_coeff') and not (lmp_tmp.angle_coeff is None):\n            f.write('Angle Coeffs\\n\\n')\n            for i in range(len(lmp_tmp.angle_coeff)):\n                f.write('{0:d} {1:f} {2:f}\\n'.format(\n                    int(lmp_tmp.angle_coeff[i, 0]), lmp_tmp.angle_coeff[i, 1], lmp_tmp.angle_coeff[i, 2]))\n            f.write('\\n')\n\n        if hasattr(lmp_tmp, 'dihedral_coeff') and not (lmp_tmp.dihedral_coeff is None):\n            f.write('Dihedral Coeffs\\n\\n')\n            for i in range(len(lmp_tmp.dihedral_coeff)):\n                f.write('{0:d} {1:f} {2:f} {3:f} {4:f}\\n'.format(int(lmp_tmp.dihedral_coeff[i, 0]), lmp_tmp.dihedral_coeff[i, 1], lmp_tmp.dihedral_coeff[i, 2],\n                                                                 lmp_tmp.dihedral_coeff[i, 3], lmp_tmp.dihedral_coeff[i, 4]))\n            f.write('\\n')\n\n        if hasattr(lmp_tmp, 'improper_coeff') and not (lmp_tmp.improper_coeff is None):\n            f.write('Improper Coeffs\\n\\n')\n            for i in range(len(lmp_tmp.improper_coeff)):\n                f.write('{0:d} {1:f} {2:d} {3:d}\\n'.format(int(lmp_tmp.improper_coeff[i, 0]), lmp_tmp.improper_coeff[i, 1], int(lmp_tmp.improper_coeff[i, 2]),\n                                                           int(lmp_tmp.improper_coeff[i, 3])))\n            f.write('\\n')\n\n        # f.write('Atoms\\n\\n')\n        # for i in range(len(lmp_tmp.atom_info)):\n        #     if lmp_tmp.atom_info.shape[1] &gt; 7:\n        #         f.write('{0:d} {1:d} {2:d} {3:f} {4:f} {5:f} {6:f} {8:d} {7:d} {9:d}\\n'.format(int(lmp_tmp.atom_info[i, 0]), int(lmp_tmp.atom_info[i, 1]), int(lmp_tmp.atom_info[i, 2]),\n        #            lmp_tmp.atom_info[i, 3], lmp_tmp.atom_info[i, 4], lmp_tmp.atom_info[i, 5], lmp_tmp.atom_info[i, 6], int(lmp_tmp.atom_info[i, 7]), int(lmp_tmp.atom_info[i, 8]), int(lmp_tmp.atom_info[i, 9])))\n        #     else:\n        #         f.write('{0:d} {1:d} {2:d} {3:f} {4:f} {5:f} {6:f}\\n'.format(int(lmp_tmp.atom_info[i, 0]), int(lmp_tmp.atom_info[i, 1]), int(lmp_tmp.atom_info[i, 2]),\n        #              lmp_tmp.atom_info[i, 3], lmp_tmp.atom_info[i, 4], lmp_tmp.atom_info[i, 5], lmp_tmp.atom_info[i, 6]))\n        # f.write('\\n')\n\n        f.write('Atoms\\n\\n')\n        lmp_tmp.atom_info = lmp_tmp.atom_info.astype(object)\n        lmp_tmp.atom_info[:, 0] = lmp_tmp.atom_info[:, 0].astype(int)\n        lmp_tmp.atom_info[:, 1] = lmp_tmp.atom_info[:, 1].astype(int)\n        if mode=='full':\n            lmp_tmp.atom_info[:, 2] = lmp_tmp.atom_info[:, 2].astype(int)\n        for row in lmp_tmp.atom_info:\n            line = []\n            for val in row:\n                if isinstance(val, float) or (isinstance(val, np.float64) or isinstance(val, np.float32)):\n                    line.append(f'{val:.6f}')\n                else:\n                    line.append(f'{int(val)}')\n            f.write(' '.join(line) + '\\n')\n        f.write('\\n')\n\n        if hasattr(lmp_tmp, 'velocity_info') and not (lmp_tmp.velocity_info is None):\n            f.write('Velocities \\n\\n')\n            for i in range(len(lmp_tmp.velocity_info)):\n                f.write('{0:d} {1:f} {2:f} {3:f}\\n'.format(int(\n                    lmp_tmp.velocity_info[i, 0]), lmp_tmp.velocity_info[i, 1], lmp_tmp.velocity_info[i, 2], lmp_tmp.velocity_info[i, 3]))\n            f.write('\\n')\n\n        if hasattr(lmp_tmp, 'bond_info') and not (lmp_tmp.bond_info is None) and not (lmp_tmp.nbonds == 0):\n            f.write('Bonds\\n\\n')\n            for i in range(len(lmp_tmp.bond_info)):\n                f.write('{0:d} {1:d} {2:d} {3:d}\\n'.format(int(lmp_tmp.bond_info[i, 0]), int(\n                    lmp_tmp.bond_info[i, 1]), int(lmp_tmp.bond_info[i, 2]), int(lmp_tmp.bond_info[i, 3])))\n            f.write('\\n')\n\n        if hasattr(lmp_tmp, 'angle_info') and not (lmp_tmp.angle_info is None) and not (lmp_tmp.nangles == 0):\n            f.write('Angles\\n\\n')\n            for i in range(len(lmp_tmp.angle_info)):\n                f.write('{0:d} {1:d} {2:d} {3:d} {4:d}\\n'.format(int(lmp_tmp.angle_info[i, 0]), int(lmp_tmp.angle_info[i, 1]), int(lmp_tmp.angle_info[i, 2]),\n                                                                 int(lmp_tmp.angle_info[i, 3]), int(lmp_tmp.angle_info[i, 4])))\n            f.write('\\n')\n\n        if hasattr(lmp_tmp, 'dihedral_info') and not (lmp_tmp.dihedral_info is None) and not (lmp_tmp.ndihedrals == 0):\n            f.write('Dihedrals\\n\\n')\n            for i in range(len(lmp_tmp.dihedral_info)):\n                f.write('{0:d} {1:d} {2:d} {3:d} {4:d} {5:d}\\n'.format(int(lmp_tmp.dihedral_info[i, 0]), int(lmp_tmp.dihedral_info[i, 1]), int(lmp_tmp.dihedral_info[i, 2]),\n                                                                       int(lmp_tmp.dihedral_info[i, 3]), int(lmp_tmp.dihedral_info[i, 4]), int(lmp_tmp.dihedral_info[i, 5])))\n            f.write('\\n')\n\n        if hasattr(lmp_tmp, 'improper_info') and not (lmp_tmp.improper_info is None) and not (lmp_tmp.nimpropers == 0):\n            f.write('Impropers\\n\\n')\n            for i in range(len(lmp_tmp.improper_info)):\n                f.write('{0:d} {1:d} {2:d} {3:d} {4:d} {5:d}\\n'.format(int(lmp_tmp.improper_info[i, 0]), int(lmp_tmp.improper_info[i, 1]), int(lmp_tmp.improper_info[i, 2]),\n                                                                       int(lmp_tmp.improper_info[i, 3]), int(lmp_tmp.improper_info[i, 4]), int(lmp_tmp.improper_info[i, 5])))\n            f.write('\\n')\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.write_lammps_atomic","title":"<code>write_lammps_atomic(file_name, lmp_tmp)</code>","text":"<p>input: file_name,lmp_tmp lmp_tmp is a class of lammps with atomic attributes,</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def write_lammps_atomic(file_name, lmp_tmp):\n    \"\"\"\n    input: file_name,lmp_tmp\n    lmp_tmp is a class of lammps with atomic attributes,\n    \"\"\"\n    with open('{}'.format(file_name), 'w') as f:\n        f.write('Generated by ZY code\\n\\n')\n\n        f.write('{} atoms\\n'.format(lmp_tmp.natoms))\n        f.write('{} atom types\\n'.format(lmp_tmp.natom_types))\n        f.write('\\n')\n\n        f.write('{0:.16f} {1:.16f} xlo xhi\\n'.format(lmp_tmp.x[0], lmp_tmp.x[1]))\n        f.write('{0:.16f} {1:.16f} ylo yhi\\n'.format(lmp_tmp.y[0], lmp_tmp.y[1]))\n        f.write('{0:.16f} {1:.16f} zlo zhi\\n'.format(lmp_tmp.z[0], lmp_tmp.z[1]))\n        f.write('\\n')\n\n        f.write('Masses\\n\\n')\n        for i in range(len(lmp_tmp.mass)):\n            if lmp_tmp.mass.shape[1] == 3:\n                f.write('{0:d} {1:.3f} # {2:s}\\n'.format(\n                    int(float(lmp_tmp.mass[i, 0])), float(lmp_tmp.mass[i, 1]), lmp_tmp.mass[i, 2]))\n            elif lmp_tmp.mass.shape[1] == 2:\n                f.write('{0:d} {1:.3f}\\n'.format(\n                    int(float(lmp_tmp.mass[i, 0])), float(lmp_tmp.mass[i, 1])))\n        f.write('\\n')\n\n        f.write('Atoms # full\\n\\n')\n        for i in range(len(lmp_tmp.atom_info)):\n            if lmp_tmp.atom_info.shape[1] &gt; 7:\n                f.write('{0:d} {1:d} {2:f} {3:f} {4:f}\\n'.format(int(lmp_tmp.atom_info[i, 0]), int(lmp_tmp.atom_info[i, 2]), lmp_tmp.atom_info[i, 4], lmp_tmp.atom_info[i, 5], lmp_tmp.atom_info[i, 6]))\n        f.write('\\n')\n</code></pre>"},{"location":"references/lmp/#m2dtools.lmp.tools_lammps.write_lammps_dump_custom","title":"<code>write_lammps_dump_custom(file_name, frame, t_list, L_list)</code>","text":"<p>input: file_name, frame, t_list, L_list output: write the frame, t_list, L_list to file_name</p> Source code in <code>m2dtools/lmp/tools_lammps.py</code> <pre><code>def write_lammps_dump_custom(file_name, frame, t_list, L_list):\n    \"\"\"\n    input: file_name, frame, t_list, L_list\n    output: write the frame, t_list, L_list to file_name\n    \"\"\"\n    f = open('{}'.format(file_name), 'w')\n    for it in range(len(t_list)):\n        f.write('ITEM: TIMESTEP\\n')\n        f.write('{}\\n'.format(t_list[it]))\n        f.write('ITEM: NUMBER OF ATOMS\\n')\n        f.write('{}\\n'.format(len(frame[it])))\n        f.write('ITEM: BOX BOUNDS pp pp pp\\n')\n        for i in range(3):\n            f.write('{} {}\\n'.format(L_list[it][i][0], L_list[it][i][1]))\n        f.write('ITEM: ATOMS ')\n        for col in frame[it].columns:\n            f.write('{} '.format(col))\n        f.write('\\n')\n        for i in range(len(frame[it])):\n            f.write('{} '.format(int(frame[it].iloc[i, 0])))\n            for j in range(1, len(frame[it].columns)):\n                # if integer, write as int, otherwise as float\n                if isinstance(frame[it].iloc[i, j], int):\n                    f.write('{0:d} '.format(int(frame[it].iloc[i, j])))\n                else:\n                    f.write('{0:.6f} '.format(frame[it].iloc[i, j]))\n            f.write('\\n')\n    f.close()\n</code></pre>"},{"location":"references/other/","title":"other","text":"<p>A collection of common functions for basic MD process: supercell, read and write POSCAR, PDF, XYZ, progressbar, replace_in_file, read_ORCA</p> <p>Tools for reading and writing .gro files</p>"},{"location":"references/other/#m2dtools.other.common.evaluate_linear_fit_np","title":"<code>evaluate_linear_fit_np(x, y)</code>","text":"<p>return r2 and MSE</p> Source code in <code>m2dtools/other/common.py</code> <pre><code>def evaluate_linear_fit_np(x, y):\n    \"\"\"\n    return r2 and MSE \n    \"\"\"\n    # Fit a linear model\n    coefficients = np.polyfit(x, y, 1)\n    polynomial = np.poly1d(coefficients)\n\n    # Predict y values\n    y_pred = polynomial(x)\n\n    # Calculate R2 score\n    ss_res = np.sum((y - y_pred) ** 2)  # MSE\n    ss_tot = np.sum((y - np.mean(y)) ** 2)\n    r2 = 1 - (ss_res / ss_tot)\n\n    return r2, np.sqrt(ss_res)\n</code></pre>"},{"location":"references/other/#m2dtools.other.common.pdf_sq_1type","title":"<code>pdf_sq_1type(box, natom, type_atom, coors, r_cutoff=10, delta_r=0.01)</code>","text":"<p>only one type of particles inputs: box,natom,type_atom,coors,r_cutoff=10,delta_r = 0.01 outputs: R,g1,Q,S1</p> Source code in <code>m2dtools/other/common.py</code> <pre><code>def pdf_sq_1type(box, natom, type_atom, coors, r_cutoff=10, delta_r=0.01):\n    \"\"\"\n    only one type of particles\n    inputs: box,natom,type_atom,coors,r_cutoff=10,delta_r = 0.01\n    outputs: R,g1,Q,S1\n    \"\"\"\n    type_atom = np.array(type_atom)\n    n1 = natom\n    rcoors = np.dot(coors, np.linalg.inv(box))\n    rdis = np.zeros([natom, natom, 3])\n    for i in range(natom):\n        tmp = rcoors[i]\n        rdis[i, :, :] = tmp - rcoors\n    rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5] + 1\n    rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5] - 1\n    a = np.dot(rdis[:, :, :], box)\n    dis = np.sqrt((np.square(a[:, :, 0]) + np.square(a[:, :, 1]) + np.square(a[:, :, 2])))\n    r_max = r_cutoff\n    r = np.linspace(delta_r, r_max, int(r_max / delta_r))\n    V = np.dot(np.cross(box[1, :], box[2, :]), box[0, :])\n    rho1 = n1 / V\n    c = np.array([rho1 * rho1]) * V\n    g1 = np.histogram(dis[:n1, :n1], bins=r)[0] / (4 * np.pi * (r[1:] - delta_r / 2) ** 2 * delta_r * c[0])\n    R = r[1:] - delta_r / 2\n\n    dq = 0.01\n    qrange = [np.pi / 2 / r_max, 25]\n    Q = np.arange(np.floor(qrange[0] / dq), np.floor(qrange[1] / dq), 1) * dq\n    S1 = np.zeros([len(Q)])\n    rho = natom / np.dot(np.cross(box[1, :], box[2, :]), box[0, :]) / 10 ** 3\n    # use a window function for fourier transform\n    for i in np.arange(len(Q)):\n        S1[i] = 1 + 4 * np.pi * rho / Q[i] * np.trapz(\n            (g1 - 1) * np.sin(Q[i] * R) * R * np.sin(np.pi * R / r_max) / (np.pi * R / r_max), R)\n\n    return R, g1, Q, S1\n</code></pre>"},{"location":"references/other/#m2dtools.other.common.read_pos","title":"<code>read_pos(file_name)</code>","text":"<p>read POSCAR format structure file for VASP calculations at this moment, only 'C' is applied input: file_name outputs: box,a_type,num_type,coors</p> Source code in <code>m2dtools/other/common.py</code> <pre><code>def read_pos(file_name):\n    \"\"\"\n    read POSCAR format structure file for VASP calculations\n    at this moment, only 'C' is applied\n    input: file_name\n    outputs: box,a_type,num_type,coors\n    \"\"\"\n    f = open(file_name, 'r')\n    lf = list(f)\n    f.close()\n    box = np.zeros((3, 3))\n    ratio = float(lf[1].split()[0])\n    box[0, :] = np.array(lf[2].split()).astype(float)*ratio\n    box[1, :] = np.array(lf[3].split()).astype(float)*ratio\n    box[2, :] = np.array(lf[4].split()).astype(float)*ratio\n    a_type = np.array(lf[5].split())\n    num_type = np.array(lf[6].split()).astype(int)\n\n    natom = np.sum(num_type)\n    coors = np.zeros((natom, 3))\n\n    if lf[7].split()[0][0] == 'C' or lf[7].split()[0][0] == 'c':\n        print('Cartesian coordinates detected in POSCAR.')\n        l = 0\n        for ia in lf[8:8+natom]:\n            coors[l, :] = np.array(ia.split()[0:3:1]).astype('float')\n            l += 1\n\n    if lf[7].split()[0][0] == 'D' or lf[7].split()[0][0] == 'd':\n        l = 0\n        rcoors = np.zeros((natom, 3))\n        for ia in lf[8:8+natom]:\n            rcoors[l, :] = np.array(ia.split()[0:3:1]).astype('float')\n            l += 1\n        coors = rcoors @ box\n    else:\n        print('Error: only Cartesian or Direct coordinates are supported in POSCAR!')\n\n    return box, a_type, num_type, coors\n</code></pre>"},{"location":"references/other/#m2dtools.other.common.replace_in_file","title":"<code>replace_in_file(file_path_old, file_path_new, old_string, new_string)</code>","text":"<p>Replace all occurrences of old_string with new_string in the file at file_path.</p> <p>:param file_path: Path to the file where the replacement will be made. :param old_string: The string to be replaced. :param new_string: The new string that will replace old_string.</p> Source code in <code>m2dtools/other/common.py</code> <pre><code>def replace_in_file(file_path_old, file_path_new, old_string, new_string):\n    \"\"\"\n    Replace all occurrences of old_string with new_string in the file at file_path.\n\n    :param file_path: Path to the file where the replacement will be made.\n    :param old_string: The string to be replaced.\n    :param new_string: The new string that will replace old_string.\n    \"\"\"\n    try:\n        # Read the content of the file\n        with open(file_path_old, 'r') as file:\n            content = file.read()\n\n        # Replace old_string with new_string\n        modified_content = content.replace(old_string, new_string)\n\n        # Write the modified content back to the file\n        with open(file_path_new, 'w') as file:\n            file.write(modified_content)\n\n        print(\"File updated successfully.\")\n    except IOError as e:\n        print(f\"An error occurred: {e}\")\n</code></pre>"},{"location":"references/other/#m2dtools.other.common.supercell","title":"<code>supercell(natoms, box0, nx, ny, nz, index0, atom_type0, coors0)</code>","text":"<p>at this moment, only for orthogonal cell</p> Source code in <code>m2dtools/other/common.py</code> <pre><code>def supercell(natoms, box0, nx, ny, nz, index0, atom_type0, coors0):\n    \"\"\"\n    at this moment, only for orthogonal cell\n    \"\"\"\n\n    box_new = box0@np.array([[nx, 0, 0], [0, ny, 0], [0, 0, nz]])\n    natoms_new = natoms*nx*ny*nz\n\n    # coors_new = np.empty([1,3])\n    # index_new = np.empty\n\n    for ix in range(nx):\n        for iy in range(ny):\n            for iz in range(nz):\n                if ix+iy+iz == 0:\n                    coors_new = coors0\n                    atom_type_new = atom_type0\n                    index_new = index0\n                    index_tmp = index0\n                else:\n                    coors_tmp = coors0 + ix*box0[0, :] + iy*box0[1, :] + iz*box0[2, :]\n                    coors_new = np.vstack((coors_new, coors_tmp))\n\n                    atom_type_new = np.concatenate((atom_type_new, atom_type0))\n                    index_tmp = index_tmp + natoms\n                    index_new = np.concatenate((index_new, index_tmp))\n\n    return natoms_new, box_new, index_new, atom_type_new, coors_new\n</code></pre>"},{"location":"references/other/#m2dtools.other.common.write_pos","title":"<code>write_pos(file_name, box, a_type, num_type, coors)</code>","text":"<p>write POSCAR format structure file for VASP calculations input: file_name,box,a_type,num_type,coors</p> Source code in <code>m2dtools/other/common.py</code> <pre><code>def write_pos(file_name, box, a_type, num_type, coors):\n    \"\"\"\n    write POSCAR format structure file for VASP calculations\n    input: file_name,box,a_type,num_type,coors\n    \"\"\"\n    f = open(file_name, 'w')\n    f.write('written by python script\\n')\n    f.write('1.0\\n')\n\n    for i in range(3):\n        f.write('{0:20.12f}{1:20.12f}{2:20.12f}\\n'.format(box[i, 0], box[i, 1], box[i, 2]))\n\n    for i in range(len(a_type)):\n        f.write(' {}'.format(a_type[i]))\n    f.write('\\n')\n    for i in range(len(a_type)):\n        f.write(' {}'.format(num_type[i]))\n    f.write('\\n')\n\n    natom = np.sum(num_type)\n    f.write('C\\n')\n    for i in range(natom):\n        f.write('{0:20.12f}{1:20.12f}{2:20.12f}\\n'.format(coors[i, 0], coors[i, 1], coors[i, 2]))\n\n    f.close()\n</code></pre>"},{"location":"references/other/#m2dtools.other.common.write_xyz_file","title":"<code>write_xyz_file(atom_types, coordinates, filename, comment='')</code>","text":"<p>Write an XYZ file from atom types and coordinates.</p> <p>Parameters: - atom_types (list of str): Atom types/symbols. - coordinates (list of list of floats): Coordinates of each atom. - filename (str): Path to the output XYZ file. - comment (str): A comment for the second line of the XYZ file.</p> Source code in <code>m2dtools/other/common.py</code> <pre><code>def write_xyz_file(atom_types, coordinates, filename, comment=\"\"):\n    \"\"\"\n    Write an XYZ file from atom types and coordinates.\n\n    Parameters:\n    - atom_types (list of str): Atom types/symbols.\n    - coordinates (list of list of floats): Coordinates of each atom.\n    - filename (str): Path to the output XYZ file.\n    - comment (str): A comment for the second line of the XYZ file.\n    \"\"\"\n    num_atoms = len(atom_types)\n    with open(filename, 'w') as file:\n        file.write(f\"{num_atoms}\\n\")\n        file.write(f\"{comment}\\n\")\n        for atom_type, (x, y, z) in zip(atom_types, coordinates):\n            file.write(f\"{atom_type} {x:.6f} {y:.6f} {z:.6f}\\n\")\n</code></pre>"},{"location":"references/other/#m2dtools.other.tools_gro.gro2pos","title":"<code>gro2pos(posfile, grofile)</code>","text":"<p>Convert .gro to POSCAR</p> Source code in <code>m2dtools/other/tools_gro.py</code> <pre><code>def gro2pos(posfile, grofile):\n    \"\"\"Convert .gro to POSCAR \"\"\"\n    box, natom, type_atom, coors0 = read_gro('{}'.format(grofile))\n\n    elements = list(set(type_atom))\n    n_elements = len(elements)\n\n    n_atom = []\n    id_atom = []\n    for i_e in range(n_elements):\n        id_atom.append(np.array(np.where(type_atom == elements[i_e]))[0])\n        n_atom.append(id_atom[i_e].shape[0])\n\n    f1 = open('{}'.format(posfile), 'w')\n    f1.write('generated by gro2pos\\n')\n    f1.write(' 1.0\\n')\n    for ib in range(3):\n        f1.write(' {0:20.12f} {1:20.12f} {2:20.12f}\\n'.format(10*box[ib, 0], 10*box[ib, 1], 10*box[ib, 2]))\n\n    for i_e in range(n_elements):\n        f1.write(' {}'.format(elements[i_e]))\n    f1.write('\\n')\n\n    for i_e in range(n_elements):\n        f1.write(' {0:8d}'.format(n_atom[i_e]))\n    f1.write('\\n')\n    f1.write('C\\n')\n    for i_e in range(n_elements):\n        for ic in range(n_atom[i_e]):\n            f1.write(' {0:20.12f} {1:20.12f} {2:20.12f}\\n'.format(10*coors0[id_atom[i_e][ic], 0], 10*coors0[id_atom[i_e][ic], 1], 10*coors0[id_atom[i_e][ic], 2]))\n\n    f1.close()\n</code></pre>"},{"location":"references/other/#m2dtools.other.tools_gro.read_gro","title":"<code>read_gro(file_name)</code>","text":"<p>return box,natom,type_atom,coors</p> Source code in <code>m2dtools/other/tools_gro.py</code> <pre><code>def read_gro(file_name):\n    \"\"\"return box,natom,type_atom,coors\"\"\"\n    f = open(file_name, 'r')\n    lf = list(f)\n    f.close()\n    len1 = float(lf[-1].split()[0])\n    len2 = float(lf[-1].split()[1])\n    len3 = float(lf[-1].split()[2])\n    box = np.diag([len1, len2, len3])\n    natom = int(lf[1])\n    coors = np.zeros([natom, 3])\n    type_atom = []\n    l = 0\n    for ia in lf[2:2+natom]:\n        if l &lt; 9999:\n            coors[l, :] = np.array(ia.split()[3:6:1]).astype('float')\n            type_atom.append(ia.split()[1])\n        else:\n            coors[l, :] = np.array(ia.split()[2:5:1]).astype('float')\n            tmp = ia.split()[1]\n            type_atom.append(re.findall(r'(\\w+?)(\\d+)', tmp)[0][0])\n        l += 1\n\n    type_atom = np.array(type_atom)\n    return box, natom, type_atom, coors\n</code></pre>"},{"location":"references/other/#m2dtools.other.tools_gro.read_gro_multi","title":"<code>read_gro_multi(gro_file)</code>","text":"<p>read multiple frames in one gro file, return a list, in which each element contains box, natom, type_atom, coors</p> Source code in <code>m2dtools/other/tools_gro.py</code> <pre><code>def read_gro_multi(gro_file):\n    \"\"\"\n    read multiple frames in one gro file,\n    return a list, in which each element contains box, natom, type_atom, coors\n    \"\"\"\n\n    f = open(gro_file)\n    lft = list(f)\n    f.close()\n    lt = []\n    t = []\n    for il in range(len(lft)):\n        if 't=' in lft[il]:\n            lt.append(il)\n            t.append(lft[il].split()[2])\n\n    def read_lf(lf):\n        len1 = float(lf[-1].split()[0])\n        len2 = float(lf[-1].split()[1])\n        len3 = float(lf[-1].split()[2])\n        box = np.diag([len1, len2, len3])\n        natom = int(lf[1])\n        coors = np.zeros([natom, 3])\n        type_atom = []\n        l = 0\n        for ia in lf[2:2+natom]:\n            if l &lt; 9999:\n                coors[l, :] = np.array(ia.split()[3:6:1]).astype('float')\n                type_atom.append(ia.split()[1])\n            else:\n                coors[l, :] = np.array(ia.split()[2:5:1]).astype('float')\n                tmp = ia.split()[1]\n                type_atom.append(re.findall(r'(\\w+?)(\\d+)', tmp)[0][0])\n            l += 1\n\n        type_atom = np.array(type_atom)\n        return box, natom, type_atom, coors\n\n    # lf=[]\n    result = []\n    for it in range(len(lt)):\n        if it == len(lt)-1:\n            #         lf.append(lft[lt[it]:])\n            result.append(read_lf(lft[lt[it]:]))\n        else:\n            #         lf.append(lft[lt[it]:lt[it+1]-1])\n            result.append(read_lf(lft[lt[it]:lt[it+1]]))\n\n    return result, t\n</code></pre>"},{"location":"references/other/#m2dtools.other.tools_gro.write_gro","title":"<code>write_gro(filename, box, natom, type_atom, coors)</code>","text":"<p>Input:filename,box,natom,type_atom,coors</p> Source code in <code>m2dtools/other/tools_gro.py</code> <pre><code>def write_gro(filename, box, natom, type_atom, coors):\n    \"\"\"Input:filename,box,natom,type_atom,coors\"\"\"\n    f = open('{}.gro'.format(filename), 'w')\n    f.write('SiO2\\n')\n    f.write('{0:5d} \\n'.format(natom))\n    for i in range(natom):\n        if i &lt; 9999:\n            f.write('{0:5d}SIO     {1:s}{2:5d}{3:8.3f}{4:8.3f}{5:8.3f}{6:8.4f}{7:8.4f}{8:8.4f}\\n'.format(i+1, type_atom[i], i+1, coors[i, 0], coors[i, 1], coors[i, 2], 0, 0, 0))\n        else:\n            f.write('{0:5d}SIO     {1:s}{2:6d}{3:8.3f}{4:8.3f}{5:8.3f}{6:8.4f}{7:8.4f}{8:8.4f}\\n'.format(i+1, type_atom[i], i+1, coors[i, 0], coors[i, 1], coors[i, 2], 0, 0, 0))\n    f.write('{0:10.5f}{1:10.5f}{2:10.5f}'.format(box[0, 0], box[1, 1], box[2, 2]))  # only work for othorgonal boxes\n    f.close()\n</code></pre>"}]}