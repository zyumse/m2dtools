{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to m2dtools Documentation","text":"<p>m2dtools is a lightweight Python toolkit for molecular simulation workflows, providing utilities for structure handling, trajectory analysis, coarse-graining, and LAMMPS interfacing. It is designed to support multiscale molecular modeling with simple, modular components that can be used independently or combined into automated pipelines.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Structure and trajectory utilities   Read, write, filter, and manipulate molecular data with minimal overhead.</p> </li> <li> <p>Coarse-graining support   Tools for computing RDFs, bonded distributions, and preparing inputs for CG   force-field optimization workflows.</p> </li> <li> <p>LAMMPS helpers   Read full-style data files, extract atom and topology information, and prepare   simulation inputs.</p> </li> <li> <p>Network and graph tools   Construct connectivity networks, compute graph-based descriptors, and analyze   polymer or molecular connectivity.</p> </li> <li> <p>Modular design   Each submodule is self-contained, making it easy to integrate with existing   workflows in MD, CGMD, or ML-accelerated simulations.</p> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install m2dtools\n</code></pre> <p>Or install from source:</p> <pre><code>git clone https://github.com/zyumse/m2dtools\ncd m2dtools\npip install -e .\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Load and inspect a LAMMPS full-style data file:</p> <pre><code>from m2dtools.lmp import read_lammps_full\n\nlmp = read_lammps_full(\"system.data\")\nprint(lmp.atom_info.shape)\nprint(lmp.bonds[:10])\n</code></pre> <p>Compute an RDF from coordinates:</p> <pre><code>from m2dtools.cg import compute_rdf\nrdf, r = compute_rdf(positions, box, dr=0.01, rmax=20.0)\n</code></pre>"},{"location":"references/basic/","title":"Basic module","text":""},{"location":"references/basic/#structure","title":"Structure","text":"<p>This module provides functions to compute structural properties of molecular systems, including bond lengths, angles, pair distribution functions (PDF), and structure factors (SQ). - compute_bond_length: Calculate bond lengths between bonded atoms. - compute_angle: Calculate angles formed by three atoms. - pdf_sq_1type: Compute pair distribution function (PDF) and structure factor (SQ) for one type of particles. - pdf_sq_cross: Compute PDF and SQ for two types of particles, excluding bonded atoms. - pdf_sq_cross_mask: Compute PDF and SQ for two types of particles with a mask matrix.</p>"},{"location":"references/basic/#m2dtools.basic.structure.angle_distribution","title":"<code>angle_distribution(coors, box, cutoff)</code>","text":"<p>compute O-O-O angle distribution in water within a cutoff distance inputs: coors, box, cutoff outputs: angles</p> Source code in <code>m2dtools/basic/structure.py</code> <pre><code>def angle_distribution(coors, box, cutoff):\n    \"\"\"\n    compute O-O-O angle distribution in water within a cutoff distance\n    inputs: coors, box, cutoff\n    outputs: angles\n    \"\"\"\n    n_atom = coors.shape[0]\n    angles = []\n    rcoors = np.dot(coors, np.linalg.inv(box))\n    rdis = np.zeros([n_atom, n_atom, 3])\n    for i in range(n_atom):\n        tmp = rcoors[i]\n        rdis[i, :, :] = tmp - rcoors\n    rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5] + 1\n    rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5] - 1\n    a = np.dot(rdis[:, :, :], box)\n    dis = np.sqrt((np.square(a[:, :, 0]) + np.square(a[:, :, 1]) + np.square(a[:, :, 2])))\n\n    for i in range(n_atom):\n        for j in np.arange(i+1, n_atom):\n            for k in np.arange(j+1, n_atom):\n                if dis[i, j] &lt; cutoff and dis[i, k] &lt; cutoff and dis[j, k] &lt; cutoff:\n                    angle = calculate_angle(a[j, i, :], a[k, i, :])\n                    angles.append(angle)\n                    angle = calculate_angle(a[i, j, :], a[k, j, :])\n                    angles.append(angle)\n                    angle = calculate_angle(a[i, k, :], a[j, k, :])\n                    angles.append(angle)\n    return angles\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.structure.calculate_angle","title":"<code>calculate_angle(v1, v2)</code>","text":"<p>Calculate the angle between two vectors.</p> Source code in <code>m2dtools/basic/structure.py</code> <pre><code>def calculate_angle(v1, v2):\n    \"\"\"Calculate the angle between two vectors.\"\"\"\n    cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))\n    # convert to angle degree\n    angle = np.arccos(cos_angle)/np.pi*180\n    return angle\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.structure.pdf_sq_1type","title":"<code>pdf_sq_1type(box_size, natom, coors, r_cutoff=10, delta_r=0.01)</code>","text":"<p>only one type of particles inputs: box,natom,type_atom,coors,r_cutoff=10,delta_r = 0.01 outputs: R,g1,Q,S1</p> Source code in <code>m2dtools/basic/structure.py</code> <pre><code>def pdf_sq_1type(box_size, natom, coors, r_cutoff=10, delta_r=0.01):\n    \"\"\"\n    only one type of particles\n    inputs: box,natom,type_atom,coors,r_cutoff=10,delta_r = 0.01\n    outputs: R,g1,Q,S1\n    \"\"\"\n    box = np.array([[box_size, 0, 0],\n                    [0, box_size, 0],\n                    [0, 0, box_size]])\n    n1 = natom\n    rcoors = np.dot(coors, np.linalg.inv(box))\n    rdis = np.zeros([natom, natom, 3])\n    for i in range(natom):\n        tmp = rcoors[i]\n        rdis[i, :, :] = tmp - rcoors\n    rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5] + 1\n    rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5] - 1\n    a = np.dot(rdis[:, :, :], box)\n    dis = np.sqrt((np.square(a[:, :, 0]) + np.square(a[:, :, 1]) + np.square(a[:, :, 2])))\n    r_max = r_cutoff\n    r = np.linspace(delta_r, r_max, int(r_max / delta_r))\n    V = np.dot(np.cross(box[1, :], box[2, :]), box[0, :])\n    rho1 = n1 / V\n    c = np.array([rho1 * rho1]) * V\n    g1 = np.histogram(dis[:n1, :n1], bins=r)[0] / (4 * np.pi *\n                                                   (r[1:] - delta_r / 2) ** 2 * delta_r * c[0])\n    R = r[1:] - delta_r / 2\n\n    dq = 0.01\n    qrange = [np.pi / 2 / r_max, 25]\n    Q = np.arange(np.floor(qrange[0] / dq), np.floor(qrange[1] / dq), 1) * dq\n    S1 = np.zeros([len(Q)])\n    rho = natom / np.dot(np.cross(box[1, :], box[2, :]), box[0, :]) #/ 10 ** 3\n    # use a window function for fourier transform\n    for i in np.arange(len(Q)):\n        S1[i] = 1 + 4 * np.pi * rho / Q[i] * np.trapz(\n            (g1 - 1) * np.sin(Q[i] * R) * R * np.sin(np.pi * R / r_max) / (np.pi * R / r_max), R)\n\n    return R, g1, Q, S1\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.structure.pdf_sq_cross","title":"<code>pdf_sq_cross(box, coors1, coors2, bond_atom_idx, r_cutoff=10, delta_r=0.01)</code>","text":"<p>compute pdf and sq for two types of particles (can be same type) inputs: box,coors1,coors2,bond_atom_idx,r_cutoff=10,delta_r = 0.01 outputs: R,g1,Q,S1</p> Source code in <code>m2dtools/basic/structure.py</code> <pre><code>def pdf_sq_cross(box, coors1, coors2,  bond_atom_idx, r_cutoff:float=10, delta_r:float=0.01):\n    \"\"\"\n    compute pdf and sq for two types of particles (can be same type)\n    inputs: box,coors1,coors2,bond_atom_idx,r_cutoff=10,delta_r = 0.01\n    outputs: R,g1,Q,S1\n    \"\"\"\n    # check if coors1 and coors2 are exactly the same\n    if np.array_equal(coors1, coors2):\n        is_same = True\n    else:\n        is_same = False\n\n    # type_atom = np.array(type_atom)\n    n1 = len(coors1)\n    n2 = len(coors2)\n    natom = n1 + n2\n    rcoors1 = np.dot(coors1, np.linalg.inv(box))\n    rcoors2 = np.dot(coors2, np.linalg.inv(box))\n    rdis = np.zeros([n1, n2, 3])\n    for i in range(n1):\n        tmp = rcoors1[i]\n        rdis[i, :, :] = tmp - rcoors2\n    rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5] + 1\n    rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5] - 1\n    a = np.dot(rdis[:, :, :], box)\n    dis = np.sqrt((np.square(a[:, :, 0]) + np.square(a[:, :, 1]) + np.square(a[:, :, 2])))\n    # Exclude bonded atoms by setting the distances to NaN\n    if bond_atom_idx is not None:\n        for bond_pair in bond_atom_idx:\n            i1 = int(bond_pair[0])\n            i2 = int(bond_pair[1])\n            dis[i1, i2] = np.nan\n            if is_same:\n                dis[i2, i1] = np.nan\n\n    r_max = r_cutoff\n    r = np.linspace(delta_r, r_max, int(r_max / delta_r))\n    V = np.dot(np.cross(box[1, :], box[2, :]), box[0, :])\n    rho1 = n1/V\n    rho2 = n2/V\n    c = np.array([rho1 * rho2]) * V\n    g1 = np.histogram(dis, bins=r)[0] / (4 * np.pi * (r[1:] - delta_r / 2) ** 2 * delta_r * c[0])\n    R = r[1:] - delta_r / 2\n\n    dq = 0.01\n    qrange = [np.pi / 2 / r_max, 25]\n    Q = np.arange(np.floor(qrange[0] / dq), np.floor(qrange[1] / dq), 1) * dq\n    S1 = np.zeros([len(Q)])\n    rho = natom / np.dot(np.cross(box[1, :], box[2, :]), box[0, :]) #/ 10 ** 3\n    # use a window function for fourier transform\n    for i in np.arange(len(Q)):\n        S1[i] = 1 + 4 * np.pi * rho / Q[i] * np.trapz(\n            (g1 - 1) * np.sin(Q[i] * R) * R * np.sin(np.pi * R / r_max) / (np.pi * R / r_max), R)\n\n    return R, g1, Q, S1\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.structure.pdf_sq_cross_mask","title":"<code>pdf_sq_cross_mask(box, coors1, coors2, mask_matrix, r_cutoff=10, delta_r=0.01)</code>","text":"<p>compute pdf and sq for two types of particles (can be same type) inputs: box,coors1,coors2, mask_matrix,r_cutoff=10,delta_r = 0.01 outputs: R,g1,Q,S1</p> Source code in <code>m2dtools/basic/structure.py</code> <pre><code>def pdf_sq_cross_mask(box, coors1, coors2,  mask_matrix, r_cutoff:float=10, delta_r:float=0.01):\n    \"\"\"\n    compute pdf and sq for two types of particles (can be same type)\n    inputs: box,coors1,coors2, mask_matrix,r_cutoff=10,delta_r = 0.01\n    outputs: R,g1,Q,S1\n    \"\"\"\n    n1 = len(coors1)\n    n2 = len(coors2)\n    natom = n1 + n2\n    rcoors1 = np.dot(coors1, np.linalg.inv(box))\n    rcoors2 = np.dot(coors2, np.linalg.inv(box))\n    rdis = np.zeros([n1, n2, 3])\n    for i in range(n1):\n        tmp = rcoors1[i]\n        rdis[i, :, :] = tmp - rcoors2\n    rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5] + 1\n    rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5] - 1\n    a = np.dot(rdis[:, :, :], box)\n    dis = np.sqrt((np.square(a[:, :, 0]) + np.square(a[:, :, 1]) + np.square(a[:, :, 2])))\n\n    dis = dis * mask_matrix\n\n    r_max = r_cutoff\n    r = np.linspace(delta_r, r_max, int(r_max / delta_r))\n    V = np.dot(np.cross(box[1, :], box[2, :]), box[0, :])\n    rho1 = n1/V\n    rho2 = n2/V\n    c = np.array([rho1 * rho2]) * V\n    g1 = np.histogram(dis, bins=r)[0] / (4 * np.pi * (r[1:] - delta_r / 2) ** 2 * delta_r * c[0])\n    R = r[1:] - delta_r / 2\n\n    dq = 0.01\n    qrange = [np.pi / 2 / r_max, 25]\n    Q = np.arange(np.floor(qrange[0] / dq), np.floor(qrange[1] / dq), 1) * dq\n    S1 = np.zeros([len(Q)])\n    rho = natom / np.dot(np.cross(box[1, :], box[2, :]), box[0, :]) #/ 10 ** 3\n    # use a window function for fourier transform\n    for i in np.arange(len(Q)):\n        S1[i] = 1 + 4 * np.pi * rho / Q[i] * np.trapz(\n            (g1 - 1) * np.sin(Q[i] * R) * R * np.sin(np.pi * R / r_max) / (np.pi * R / r_max), R)\n\n    return R, g1, Q, S1\n</code></pre>"},{"location":"references/basic/#dynamics","title":"Dynamics","text":"<p>Module for computing mean-squared displacement (MSD) with periodic boundary conditions</p>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_D","title":"<code>compute_D(time, msd, fit_from=0, dim=3)</code>","text":"<p>Compute diffusion coefficient from MSD using linear fit.</p>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_D--parameters","title":"Parameters:","text":"<p>time : np.ndarray     Time array corresponding to the MSD values. msd : np.ndarray     Mean-squared displacement array. fit_from : int     Index to start the linear fit from. dim : int     Dimensionality of the system (default is 3 for 3D).</p>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_D--returns","title":"Returns:","text":"<p>D : float     Diffusion coefficient.</p> Source code in <code>m2dtools/basic/dynamics.py</code> <pre><code>def compute_D(time, msd, fit_from=0, dim=3):\n    \"\"\"\n    Compute diffusion coefficient from MSD using linear fit.\n\n    Parameters:\n    -----------\n    time : np.ndarray\n        Time array corresponding to the MSD values.\n    msd : np.ndarray\n        Mean-squared displacement array.\n    fit_from : int\n        Index to start the linear fit from.\n    dim : int\n        Dimensionality of the system (default is 3 for 3D).\n\n    Returns:\n    --------\n    D : float\n        Diffusion coefficient.\n    \"\"\"\n    coeffs = np.polyfit(time[fit_from:], msd[fit_from:], 1)\n    D = coeffs[0] / 2 / dim # in unit of msd / time\n    return D\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_msd_pbc","title":"<code>compute_msd_pbc(positions, box_lengths, lag_array)</code>","text":"<p>Compute mean-squared displacement (MSD) considering periodic boundary conditions.</p>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_msd_pbc--parameters","title":"Parameters:","text":"<p>positions : np.ndarray     Atom positions array of shape (n_frames, n_atoms, 3). box_lengths : np.ndarray or list     Simulation box lengths of shape (n_frames, 3). lag_array : np.ndarray or list     Array of lag times for which to compute the MSD.</p>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_msd_pbc--returns","title":"Returns:","text":"<p>msd : np.ndarray     Mean-squared displacement as 1D array of length max_lag.</p> Source code in <code>m2dtools/basic/dynamics.py</code> <pre><code>def compute_msd_pbc(positions, box_lengths, lag_array):\n    \"\"\"\n    Compute mean-squared displacement (MSD) considering periodic boundary conditions.\n\n    Parameters:\n    -----------\n    positions : np.ndarray\n        Atom positions array of shape (n_frames, n_atoms, 3).\n    box_lengths : np.ndarray or list\n        Simulation box lengths of shape (n_frames, 3).\n    lag_array : np.ndarray or list\n        Array of lag times for which to compute the MSD.\n\n    Returns:\n    --------\n    msd : np.ndarray\n        Mean-squared displacement as 1D array of length max_lag.\n    \"\"\"\n    n_frames, n_atoms, _ = positions.shape\n\n    # Unwrap positions considering periodic boundary conditions\n    unwrapped_pos = np.zeros_like(positions)\n    unwrapped_pos[0] = positions[0]\n\n    for t in range(1, n_frames):\n        box_length_tmp = (box_lengths[t] + box_lengths[t - 1]) / 2\n        delta = positions[t] - unwrapped_pos[t - 1]\n        delta -= box_length_tmp * np.round(delta / box_length_tmp)\n        unwrapped_pos[t] = unwrapped_pos[t - 1] + delta\n\n    msd = np.zeros(len(lag_array))\n\n    for i, lag in enumerate(lag_array):\n        displacements = unwrapped_pos[lag:] - unwrapped_pos[:-lag]\n        squared_displacements = np.sum(displacements**2, axis=2)\n        msd[i] = np.mean(squared_displacements)\n\n    return msd\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_self_intermediate_scattering_function","title":"<code>compute_self_intermediate_scattering_function(positions, box_lengths, lag_array, k, num_vectors=100, n_repeat=100)</code>","text":"<p>Compute self-intermediate scattering function (SISF) considering periodic boundary conditions.</p>"},{"location":"references/basic/#m2dtools.basic.dynamics.compute_self_intermediate_scattering_function--parameters","title":"Parameters:","text":"<p>positions : np.ndarray     Atom positions array of shape (n_frames, n_atoms, 3). box_lengths : np.ndarray or list     Simulation box lengths of shape (n_frames, 3). lag_array : np.ndarray or list     Array of lag times for which to compute the SISF. k : absolute value of wave vector num_vectors : int     Number of random k-vectors to average over. n_repeat : int     Number of time origins to average over. Returns:</p> <p>sisf : np.ndarray     Self-intermediate scattering function as 1D array of length max_lag.</p> Source code in <code>m2dtools/basic/dynamics.py</code> <pre><code>def compute_self_intermediate_scattering_function(positions, box_lengths, lag_array, k, num_vectors=100, n_repeat=100):\n    \"\"\"\n    Compute self-intermediate scattering function (SISF) considering periodic boundary conditions.\n\n    Parameters:\n    -----------\n    positions : np.ndarray\n        Atom positions array of shape (n_frames, n_atoms, 3).\n    box_lengths : np.ndarray or list\n        Simulation box lengths of shape (n_frames, 3).\n    lag_array : np.ndarray or list\n        Array of lag times for which to compute the SISF.\n    k : absolute value of wave vector\n    num_vectors : int\n        Number of random k-vectors to average over.\n    n_repeat : int\n        Number of time origins to average over.\n    Returns:\n    --------\n    sisf : np.ndarray\n        Self-intermediate scattering function as 1D array of length max_lag.\n    \"\"\"\n    n_frames, n_atoms, _ = positions.shape\n\n    # Unwrap positions considering periodic boundary conditions\n    unwrapped_pos = np.zeros_like(positions)\n    unwrapped_pos[0] = positions[0]\n\n    for t in range(1, n_frames):\n        box_length_tmp = (box_lengths[t] + box_lengths[t - 1]) / 2\n        delta = positions[t] - unwrapped_pos[t - 1]\n        delta -= box_length_tmp * np.round(delta / box_length_tmp)\n        unwrapped_pos[t] = unwrapped_pos[t - 1] + delta\n\n    sisf = np.zeros(len(lag_array))\n    vectors=random_vectors(k, num_vectors)  \n    for i, lag in enumerate(lag_array):\n        if len(positions)-lag &lt; n_repeat:\n            displacements = unwrapped_pos[lag:] - unwrapped_pos[:-lag]\n            #compute cos(k*r) for each random vector and average\n            cos_kr = np.cos(np.einsum('ij,tkj-&gt;tki', vectors, displacements))\n        else:\n            random_indices = np.random.choice(len(positions)-lag, n_repeat)\n            displacements = unwrapped_pos[lag + random_indices] - unwrapped_pos[random_indices]\n            cos_kr = np.cos(np.einsum('ij,tkj-&gt;tki', vectors, displacements))\n        sisf[i] = np.mean(cos_kr)\n    return sisf\n</code></pre>"},{"location":"references/basic/#basic","title":"Basic","text":"<p>Basic analysis functions for molecular dynamics simulations. - CN: Calculate coordination numbers and neighbor indices within a cutoff distance. - CN_large: Calculate coordination numbers for large systems using a cubic search method. - angle_distribution: Compute angle distribution for triplets of atoms within a cutoff distance. - compute_autocorrelation: Compute force autocorrelation function (FAF). - compute_msd_pbc: Compute mean-squared displacement (MSD) considering periodic boundary conditions. - calc_compressibility: Calculate compressibility from volume fluctuations.</p>"},{"location":"references/basic/#m2dtools.basic.basic.CN","title":"<code>CN(box, coors, cutoff)</code>","text":"<p>return CN, CN_idx, CN_dist, diff</p> Source code in <code>m2dtools/basic/basic.py</code> <pre><code>def CN(box, coors, cutoff):\n    \"\"\" \n    return CN, CN_idx, CN_dist, diff \n    \"\"\"\n\n    rcoors = np.dot(coors, np.linalg.inv(box))\n\n    r1 = rcoors[:, np.newaxis, :]\n    r2 = rcoors[np.newaxis, :, :]\n\n    rdis = r1-r2\n\n    while np.sum((rdis &lt; -0.5) | (rdis &gt; 0.5)) &gt; 0:\n        rdis[rdis &lt; -0.5] = rdis[rdis &lt; -0.5]+1\n        rdis[rdis &gt; 0.5] = rdis[rdis &gt; 0.5]-1\n\n    diff = np.dot(rdis, box)\n\n    dis = np.sqrt(np.sum(np.square(diff), axis=2))\n\n    CN_idx = []\n    CN_dist = []\n    CN = np.zeros(coors.shape[0])\n    for i in range(coors.shape[0]):\n        tmp = np.argwhere((dis[i, :] &lt; cutoff) &amp; (dis[i, :] &gt; 0))\n        CN[i] = tmp.shape[0]\n        CN_idx.append(tmp)\n        CN_dist.append(dis[i, (dis[i, :] &lt; cutoff) &amp; (dis[i, :] &gt; 0)])\n    return CN, CN_idx, CN_dist, diff\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.basic.CN_large","title":"<code>CN_large(box, coors, cutoff)</code>","text":"<p>return CN, CN_idx, CN_dist</p> Source code in <code>m2dtools/basic/basic.py</code> <pre><code>def CN_large(box, coors, cutoff):\n    \"\"\"\n    return CN, CN_idx, CN_dist\n    \"\"\"\n    CN = []\n    CN_idx = []\n    CN_dist = []\n    for i in range(coors.shape[0]):\n        # find atom in the cubic at the center of coord[1], within the cutoff\n        coord0 = coors[i]\n        diff_coord = coors - coord0\n        # periodic boundary condition\n        diff_coord = diff_coord - np.round(diff_coord @ np.linalg.inv(box) ) @ box\n        idx_interest = np.argwhere((diff_coord[:, 0] &gt;= -cutoff)*(diff_coord[:, 0] &lt;= cutoff)*(diff_coord[:, 1] &gt;= -cutoff)*(diff_coord[:, 1] &lt;= cutoff)*(diff_coord[:, 2] &gt;= -cutoff)*(diff_coord[:, 2] &lt;= cutoff)).flatten()\n        dist_tmp = np.linalg.norm(diff_coord[idx_interest,:], axis=1)\n        idx_CN_tmp = np.argwhere(dist_tmp&lt;=cutoff).flatten()\n        CN.append(idx_CN_tmp.shape[0])\n        CN_idx.append(idx_interest[idx_CN_tmp])\n        CN_dist.append(dist_tmp[idx_CN_tmp])\n    return CN, CN_idx, CN_dist\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.basic.calc_compressibility","title":"<code>calc_compressibility(V, T=300)</code>","text":"<p>Calculate compressibility from volume and temperature. :param V: Volume in nm^3 :param T: Temperature in K :return: Compressibility in 1/Pa</p> Source code in <code>m2dtools/basic/basic.py</code> <pre><code>def calc_compressibility(V, T=300):\n    \"\"\"\n    Calculate compressibility from volume and temperature.\n    :param V: Volume in nm^3\n    :param T: Temperature in K\n    :return: Compressibility in 1/Pa\n    \"\"\"\n    kB = 1.380649e-23  # J/K\n    V = V * 1e-27  # Convert from nm^3 to m^3\n    kappa_T = np.var(V) / (V.mean() * kB * T)\n    return kappa_T * 1e9 # to 1/GPa\n</code></pre>"},{"location":"references/basic/#m2dtools.basic.basic.compute_autocorrelation","title":"<code>compute_autocorrelation(forces, max_lag)</code>","text":"<p>Compute the force autocorrelation function (FAF).</p>"},{"location":"references/basic/#m2dtools.basic.basic.compute_autocorrelation--parameters","title":"Parameters:","text":"<p>forces : np.ndarray     Array of shape (n_frames, n_atoms, 3), forces per atom. max_lag : int     Maximum lag time (in frames) for computing the autocorrelation.</p>"},{"location":"references/basic/#m2dtools.basic.basic.compute_autocorrelation--returns","title":"Returns:","text":"<p>faf : np.ndarray     Force autocorrelation function as a 1D array of length max_lag.</p> Source code in <code>m2dtools/basic/basic.py</code> <pre><code>def compute_autocorrelation(forces, max_lag):\n    \"\"\"\n    Compute the force autocorrelation function (FAF).\n\n    Parameters:\n    -----------\n    forces : np.ndarray\n        Array of shape (n_frames, n_atoms, 3), forces per atom.\n    max_lag : int\n        Maximum lag time (in frames) for computing the autocorrelation.\n\n    Returns:\n    --------\n    faf : np.ndarray\n        Force autocorrelation function as a 1D array of length max_lag.\n    \"\"\"\n    n_frames, n_atoms, _ = forces.shape\n\n    # Initialize autocorrelation array\n    faf = np.zeros(max_lag)\n\n    # Loop over lag times\n    for lag in range(max_lag):\n        # Compute dot product of forces separated by lag\n        dot_products = np.sum(forces[:n_frames - lag] * forces[lag:], axis=(1, 2))\n        faf[lag] = np.mean(dot_products)\n\n    # Normalize by the zero-lag correlation\n    faf /= faf[0]\n\n    return faf\n</code></pre>"}]}